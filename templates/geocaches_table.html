<!-- Template pour le tableau des géocaches -->
<!--
DOCUMENTATION DU SYSTÈME DE FILTRAGE DES GÉOCACHES

Ce système permet de filtrer les géocaches affichées dans le tableau selon différents critères.

1. FILTRES SIMPLES
   - Recherche rapide : filtre sur le nom, code GC ou type de cache
   - Statut : filtre sur l'état de résolution (résolue, non résolue, en cours)
   - Type : filtre sur le type de cache (Traditional, Mystery, etc.)

2. FILTRES AVANCÉS
   Les filtres avancés permettent des critères plus précis avec différents opérateurs :
   - Difficulté/Terrain : valeurs de 1 à 5 (par 0.5)
   - Type : types disponibles dans la base de données
   - Statut : résolue, non résolue, en cours
   - Taille : Micro, Small, Regular, Large, Other
   - Favoris/Logs : nombre de favoris ou logs

3. OPÉRATEURS DISPONIBLES
   - Égal à / Différent de : comparaison exacte
   - Supérieur/Inférieur à : pour les valeurs numériques
   - Parmi : sélection multiple

4. PARTICULARITÉS TECHNIQUES
   - Les comparaisons sont insensibles à la casse pour certains champs (ex: taille)
   - Les valeurs des champs (types, tailles) sont détectées automatiquement depuis les données
   - Le système utilise le même algorithme pour le filtrage à l'écran et pour la sélection des géocaches à supprimer

5. SUPPRESSION MULTIPLE
   - Le bouton "Supprimer les géocaches filtrées" permet de supprimer toutes les géocaches correspondant aux filtres actuels
   - Le bouton "Conserver uniquement les filtrées" permet de supprimer toutes les géocaches ne correspondant PAS aux filtres actuels
   - La confirmation indique clairement le nombre de géocaches qui seront supprimées
-->

<div class="w-full h-full bg-gray-900 flex flex-col overflow-hidden">
    <!-- Formulaire d'ajout de géocache -->
    <div class="flex-shrink-0 gap-4 items-end p-4">
        <div class="flex justify-between w-full">
            <div class="flex gap-4">
                <form id="addGeocacheForm" class="flex gap-4 items-end">
                    <div>
                        <label for="geocacheCode" class="block text-sm font-medium text-gray-300">Code GC</label>
                        <input type="text" id="geocacheCode" name="code" required
                               class="mt-1 block w-full rounded-md border-gray-600 bg-gray-700 text-gray-100 shadow-sm focus:border-blue-500 focus:ring-blue-500 sm:text-sm"
                               placeholder="GC12345">
                        <input type="hidden" name="zone_id" value="{{ zone_id }}">
                    </div>
                    <button type="submit" 
                            class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded inline-flex items-center">
                        <span>Ajouter</span>
                        <div class="loading-indicator hidden ml-2">
                            <div class="animate-spin h-5 w-5 border-2 border-white border-t-transparent rounded-full"></div>
                        </div>
                    </button>
                </form>
                
                <!-- Bouton d'importation GPX -->
                <button id="importGpxButton" 
                        class="bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded inline-flex items-center gap-2">
                    <i class="fas fa-file-import"></i>
                    <span>Importer GPX</span>
                </button>
            </div>
            <button id="openMapButton" 
                    class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded inline-flex items-center gap-2"
                    data-zone-id="{{ zone_id }}">
                <i class="fas fa-map-marked-alt"></i>
                <span>Map</span>
            </button>
        </div>
        <div id="spinner" class="spinner"></div>
        <div id="message" class="mt-2"></div>
    </div>

    <!-- Filtre pour le tableau des géocaches -->
    <div class="px-4 pb-4">
        <div class="flex flex-wrap gap-4">
            <div class="flex-1 min-w-[300px]">
                <label for="tableFilter" class="block text-sm font-medium text-gray-300 mb-1">Recherche rapide</label>
                <div class="relative">
                    <input type="text" id="tableFilter" placeholder="Rechercher par nom, code, type, ..."
                           class="block w-full rounded-md border-gray-600 bg-gray-700 text-gray-100 shadow-sm focus:border-blue-500 focus:ring-blue-500 sm:text-sm pl-10">
                    <div class="absolute inset-y-0 left-0 flex items-center pl-3 pointer-events-none">
                        <i class="fas fa-search text-gray-400"></i>
                    </div>
                    <button id="clearFilter" class="absolute inset-y-0 right-0 flex items-center pr-3 text-gray-400 hover:text-white">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
            </div>
            <!-- Anciens filtres simples (on les garde pour la compatibilité) -->
            <div>
                <label for="statusFilter" class="block text-sm font-medium text-gray-300 mb-1">Statut</label>
                <select id="statusFilter" class="rounded-md border-gray-600 bg-gray-700 text-gray-100 shadow-sm focus:border-blue-500 focus:ring-blue-500 sm:text-sm">
                    <option value="">Tous les statuts</option>
                    <option value="solved">Résolues</option>
                    <option value="not_solved">Non résolues</option>
                    <option value="ongoing">En cours</option>
                </select>
            </div>
            <div>
                <label for="typeFilter" class="block text-sm font-medium text-gray-300 mb-1">Type</label>
                <select id="typeFilter" class="rounded-md border-gray-600 bg-gray-700 text-gray-100 shadow-sm focus:border-blue-500 focus:ring-blue-500 sm:text-sm">
                    <option value="">Tous les types</option>
                    <!-- Options seront remplies dynamiquement via JavaScript -->
                </select>
            </div>
        </div>

        <!-- Système de filtres avancés -->
        <div class="mt-4">
            <div class="flex justify-between items-center mb-2">
                <h3 class="text-sm font-medium text-gray-300">Filtres avancés</h3>
                <div class="flex gap-2">
                    <button id="clear-all-filters-btn" class="bg-gray-600 hover:bg-gray-700 text-white text-sm py-1 px-2 rounded inline-flex items-center gap-1 hidden">
                        <i class="fas fa-trash-alt"></i> Supprimer tous les filtres
                    </button>
                    <button id="add-filter-btn" class="bg-blue-600 hover:bg-blue-700 text-white text-sm py-1 px-2 rounded inline-flex items-center gap-1">
                        <i class="fas fa-plus"></i> Ajouter un filtre
                    </button>
                </div>
            </div>
            
            <!-- Liste des filtres actifs -->
            <div id="active-filters" class="flex flex-wrap gap-2 mb-3">
                <!-- Les filtres actifs seront ajoutés ici dynamiquement -->
            </div>
            
            <!-- Formulaire d'ajout de filtre (invisible par défaut) -->
            <div id="filter-form" class="bg-gray-800 p-3 rounded-md mb-3 hidden">
                <div class="grid grid-cols-1 md:grid-cols-4 gap-2 mb-2">
                    <div>
                        <label for="filter-field" class="block text-xs font-medium text-gray-300 mb-1">Champ</label>
                        <select id="filter-field" class="w-full text-sm rounded-md border-gray-600 bg-gray-700 text-gray-100 shadow-sm focus:border-blue-500 focus:ring-blue-500">
                            <option value="difficulty">Difficulté</option>
                            <option value="terrain">Terrain</option>
                            <option value="cache_type">Type</option>
                            <option value="solved">Statut</option>
                            <option value="size">Taille</option>
                            <option value="favorites_count">Favoris</option>
                            <option value="logs_count">Logs</option>
                        </select>
                    </div>
                    <div>
                        <label for="filter-operator" class="block text-xs font-medium text-gray-300 mb-1">Condition</label>
                        <select id="filter-operator" class="w-full text-sm rounded-md border-gray-600 bg-gray-700 text-gray-100 shadow-sm focus:border-blue-500 focus:ring-blue-500">
                            <!-- Options dynamiques selon le champ -->
                        </select>
                    </div>
                    <div>
                        <label for="filter-value" class="block text-xs font-medium text-gray-300 mb-1">Valeur</label>
                        <select id="filter-value" class="w-full text-sm rounded-md border-gray-600 bg-gray-700 text-gray-100 shadow-sm focus:border-blue-500 focus:ring-blue-500">
                            <!-- Options dynamiques selon le champ -->
                        </select>
                    </div>
                    <div class="flex items-end">
                        <button id="apply-filter-btn" class="bg-green-600 hover:bg-green-700 text-white text-sm py-1 px-3 rounded mr-2">
                            Appliquer
                        </button>
                        <button id="cancel-filter-btn" class="bg-gray-600 hover:bg-gray-700 text-white text-sm py-1 px-3 rounded">
                            Annuler
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <div class="mt-4 flex justify-end">
            <div class="flex justify-between items-center mb-4">
                <div class="flex space-x-3">
                    <div id="selected-count-container-{{ zone_id }}" class="hidden">
                        <span class="bg-indigo-600 text-white px-2 py-1 rounded" id="selected-count-{{ zone_id }}">0</span>
                        <span class="text-gray-300">géocaches sélectionnées</span>
                    </div>
                </div>
                <div class="flex gap-3">
                    <button id="keep-filtered-btn-{{ zone_id }}" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-1 px-3 rounded">
                        <i class="fas fa-filter mr-1"></i> Conserver uniquement les filtrées
                    </button>
                    <button id="copy-to-zone-btn-{{ zone_id }}" class="bg-green-600 hover:bg-green-700 text-white font-bold py-1 px-3 rounded">
                        <i class="fas fa-copy mr-1"></i> Copier vers une zone
                    </button>
                    <button id="move-to-zone-btn-{{ zone_id }}" class="bg-yellow-600 hover:bg-yellow-700 text-white font-bold py-1 px-3 rounded">
                        <i class="fas fa-share mr-1"></i> Déplacer vers une zone
                    </button>
                    <button id="reset-coordinates-btn-{{ zone_id }}" class="bg-orange-600 hover:bg-orange-700 text-white font-bold py-1 px-3 rounded">
                        <i class="fas fa-undo-alt mr-1"></i> Réinitialiser les coordonnées
                    </button>
                    <button id="solve-filtered-btn-{{ zone_id }}" class="bg-purple-600 hover:bg-purple-700 text-white font-bold py-1 px-3 rounded">
                        <i class="fas fa-puzzle-piece mr-1"></i> Résoudre les caches filtrées
                    </button>
                    <button id="delete-selected-btn-{{ zone_id }}" class="bg-red-600 hover:bg-red-700 text-white font-bold py-1 px-3 rounded">
                        <i class="fas fa-trash mr-1"></i> Supprimer les géocaches filtrées
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Modal de confirmation de suppression multiple -->
    <div id="deleteMultipleModal-{{ zone_id }}" class="delete-multiple-modal fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
        <div class="bg-gray-800 p-6 rounded-lg shadow-lg w-full max-w-md">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-xl font-bold text-red-500">Confirmer la suppression</h3>
                <button class="close-delete-multiple-modal text-gray-400 hover:text-white">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <p class="text-gray-300 mb-6">Êtes-vous sûr de vouloir supprimer <span class="geocaches-count-to-delete font-semibold">0</span> géocaches correspondant aux filtres actuels ? Cette action est irréversible et affectera toutes les géocaches filtrées, même celles qui ne sont pas visibles à l'écran.</p>
            <div class="flex justify-end gap-2">
                <button class="cancel-delete-multiple bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded">
                    Annuler
                </button>
                <button class="confirm-delete-multiple bg-red-500 hover:bg-red-700 text-white font-bold py-2 px-4 rounded inline-flex items-center">
                    <span>Supprimer</span>
                    <div class="delete-loading-indicator hidden ml-2">
                        <div class="animate-spin h-5 w-5 border-2 border-white border-t-transparent rounded-full"></div>
                    </div>
                </button>
            </div>
        </div>
    </div>

    <!-- Modal d'importation GPX -->
    <div id="importGpxModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
        <div class="bg-gray-800 p-6 rounded-lg shadow-lg w-full max-w-md">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-xl font-bold text-white">Importer des géocaches</h3>
                <button id="closeImportModal" class="text-gray-400 hover:text-white">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <form id="importGpxForm" enctype="multipart/form-data">
                <div class="mb-4">
                    <label for="gpxFile" class="block text-sm font-medium text-gray-300 mb-2">Fichier GPX ou ZIP</label>
                    <input type="file" id="gpxFile" name="gpxFile" accept=".gpx,.zip" required
                           class="block w-full text-gray-300 file:mr-4 file:py-2 file:px-4 file:rounded file:border-0 file:bg-blue-500 file:text-white hover:file:bg-blue-600">
                    <p class="text-xs text-gray-400 mt-1">Formats acceptés: .gpx (Pocket Query) ou .zip contenant des fichiers GPX</p>
                    <input type="hidden" name="zone_id" value="{{ zone_id }}">
                </div>
                <div class="mb-4">
                    <div class="flex items-center">
                        <input type="checkbox" id="updateExisting" name="updateExisting" class="h-4 w-4 text-blue-600 rounded border-gray-600 bg-gray-700 focus:ring-blue-500">
                        <label for="updateExisting" class="ml-2 block text-sm text-gray-300">
                            Mettre à jour les waypoints des géocaches existantes
                        </label>
                    </div>
                    <p class="text-xs text-gray-400 mt-1">Si coché, les waypoints additionnels seront ajoutés aux géocaches déjà existantes</p>
                </div>
                <div class="flex justify-end gap-2">
                    <button type="button" id="cancelImport" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded">
                        Annuler
                    </button>
                    <button type="submit" class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded inline-flex items-center">
                        <span>Importer</span>
                        <div class="import-loading-indicator hidden ml-2">
                            <div class="animate-spin h-5 w-5 border-2 border-white border-t-transparent rounded-full"></div>
                        </div>
                    </button>
                </div>
            </form>
            <div id="importProgress" class="mt-4 hidden">
                <div class="text-sm text-gray-300 mb-1">Progression: <span id="importProgressText">0%</span></div>
                <div class="w-full bg-gray-700 rounded-full h-2.5">
                    <div id="importProgressBar" class="bg-blue-600 h-2.5 rounded-full" style="width: 0%"></div>
                </div>
            </div>
            <div id="importMessage" class="mt-4 text-sm"></div>
        </div>
    </div>

    <!-- Modal de sélection de zone -->
    <div id="copyToZoneModal-{{ zone_id }}" class="copy-to-zone-modal fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
        <div class="bg-gray-800 p-6 rounded-lg shadow-lg w-full max-w-md">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-xl font-bold text-green-500">Copier vers une zone</h3>
                <button class="close-copy-to-zone-modal text-gray-400 hover:text-white">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <p class="text-gray-300 mb-4">Sélectionnez la zone où copier <span class="geocaches-count-to-copy font-semibold">0</span> géocaches :</p>
            
            <div class="mb-4">
                <select id="target-zone-select-{{ zone_id }}" class="w-full rounded-md border-gray-600 bg-gray-700 text-gray-100 shadow-sm focus:border-blue-500 focus:ring-blue-500">
                    <option value="">Choisir une zone...</option>
                </select>
            </div>

            <div class="flex justify-end gap-2">
                <button class="cancel-copy-to-zone bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded">
                    Annuler
                </button>
                <button class="confirm-copy-to-zone bg-green-500 hover:bg-green-700 text-white font-bold py-2 px-4 rounded inline-flex items-center">
                    <span>Copier</span>
                    <div class="copy-loading-indicator hidden ml-2">
                        <div class="animate-spin h-5 w-5 border-2 border-white border-t-transparent rounded-full"></div>
                    </div>
                </button>
            </div>
        </div>
    </div>

    <!-- Conteneur du tableau -->
    <div class="flex-1 min-h-0 overflow-hidden">
        <div id="geocaches-table-{{ zone_id }}" class="w-full h-full overflow-auto"
             data-zone-id="{{ zone_id }}"
             data-api-url="{{ url_for('geocaches.get_geocaches', zone_id=zone_id) }}">
            {% include 'geocaches_table_content.html' %}
        </div>
    </div>
</div>

<style>
    .spinner {
        display: none;
        width: 40px;
        height: 40px;
        border: 4px solid #f3f3f3;
        border-top: 4px solid #3498db;
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin: 10px auto;
    }

    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }

    /* Styles pour Tabulator */
    .tabulator {
        background-color: transparent !important;
        border: none !important;
        color: #e1e1e1 !important;
        font-size: 14px !important;
    }

    .tabulator-header {
        background-color: #1a1a1a !important;
        border-bottom: 1px solid #2d2d2d !important;
        color: #e1e1e1 !important;
        font-weight: 600 !important;
    }

    .tabulator-header .tabulator-col {
        background-color: #1a1a1a !important;
        border-right: 1px solid #2d2d2d !important;
        padding: 8px !important;
    }

    .tabulator-header .tabulator-col-content {
        padding: 8px !important;
    }

    .tabulator-col-title {
        color: #e1e1e1 !important;
    }

    .tabulator-row {
        background-color: #1e1e1e !important;
        border-bottom: 1px solid #2d2d2d !important;
        color: #e1e1e1 !important;
    }

    .tabulator-row.tabulator-row-even {
        background-color: #252525 !important;
    }

    .tabulator-row.tabulator-selectable:hover {
        background-color: #2d2d2d !important;
    }

    .tabulator-row .tabulator-cell {
        padding: 8px !important;
        border-right: 1px solid #2d2d2d !important;
    }

    .tabulator-tableholder {
        background-color: transparent !important;
        overflow-y: auto !important;
        overflow-x: auto !important;
    }

    /* Style pour les barres de défilement de Tabulator */
    .tabulator-tableholder::-webkit-scrollbar {
        width: 10px;
        height: 10px;
    }

    .tabulator-tableholder::-webkit-scrollbar-track {
        background: #1e1e1e;
        border-radius: 5px;
    }

    .tabulator-tableholder::-webkit-scrollbar-thumb {
        background: #3c3c3c;
        border-radius: 5px;
        border: 2px solid #1e1e1e;
    }

    .tabulator-tableholder::-webkit-scrollbar-thumb:hover {
        background: #4c4c4c;
    }

    /* Support Firefox */
    .tabulator-tableholder {
        scrollbar-width: thin;
        scrollbar-color: #3c3c3c #1e1e1e;
    }

    /* Style pour les en-têtes de colonnes triables */
    .tabulator-col.tabulator-sortable:hover {
        background-color: #2d2d2d !important;
    }

    .tabulator-col.tabulator-sortable[aria-sort="none"] .tabulator-col-content:after {
        border-top: 4px solid #666 !important;
    }

    .tabulator-col.tabulator-sortable[aria-sort="asc"] .tabulator-col-content:after {
        border-bottom: 4px solid #e1e1e1 !important;
    }

    .tabulator-col.tabulator-sortable[aria-sort="desc"] .tabulator-col-content:after {
        border-top: 4px solid #e1e1e1 !important;
    }

    /* Style pour les cellules spécifiques */
    .tabulator-row .tabulator-cell[tabulator-field="solved"] {
        font-weight: 600 !important;
    }

    /* Style pour les boutons d'action */
    .action-button {
        @apply font-bold py-1 px-2 rounded mr-2;
        transition: all 0.2s ease-in-out;
    }

    .details-button {
        @apply bg-blue-500 hover:bg-blue-700 text-white action-button;
    }

    .delete-button {
        @apply bg-red-500 hover:bg-red-700 text-white action-button;
    }
</style>

<script type="text/javascript">
    // S'assurer que le script s'exécute dans l'iframe
    (function() {
        console.log("Initialisation du tableau des géocaches pour la zone {{ zone_id }}");
        
        // Déplacer les modales vers le conteneur global des modales
        function moveModalsToGlobalContainer() {
            const modalContainer = window.parent.document.getElementById('modals-container');
            if (modalContainer) {
                // Modale de suppression multiple
                const deleteMultipleModal = document.getElementById('deleteMultipleModal-{{ zone_id }}');
                if (deleteMultipleModal) {
                    // Vérifier si la modale existe déjà dans le conteneur global
                    const existingModal = modalContainer.querySelector('#deleteMultipleModal-{{ zone_id }}');
                    if (existingModal) {
                        // Si elle existe, la supprimer pour éviter les doublons
                        existingModal.remove();
                    }
                    
                    // Cloner la modale et l'ajouter au conteneur global
                    const clonedModal = deleteMultipleModal.cloneNode(true);
                    modalContainer.appendChild(clonedModal);
                    
                    // Supprimer la modale originale
                    deleteMultipleModal.remove();
                }
                
                // Modale d'importation GPX (si elle existe)
                const importGpxModal = document.getElementById('importGpxModal');
                if (importGpxModal) {
                    // Vérifier si la modale existe déjà dans le conteneur global
                    const existingImportModal = modalContainer.querySelector('#importGpxModal-{{ zone_id }}');
                    if (existingImportModal) {
                        existingImportModal.remove();
                    }
                    
                    // Renommer la modale pour éviter les conflits
                    importGpxModal.id = 'importGpxModal-{{ zone_id }}';
                    
                    // Cloner et ajouter au conteneur global
                    const clonedImportModal = importGpxModal.cloneNode(true);
                    modalContainer.appendChild(clonedImportModal);
                    
                    // Supprimer la modale originale
                    importGpxModal.remove();
                }
            }
        }
        
        // Appeler cette fonction pour déplacer les modales dès que possible
        setTimeout(moveModalsToGlobalContainer, 0);
        
        const form = document.getElementById('addGeocacheForm');
        const loadingIndicator = form.querySelector('.loading-indicator');
        const spinner = document.getElementById('spinner');
        const messageDiv = document.getElementById('message');
        const submitButton = form.querySelector('button[type="submit"]');
        const openMapButton = document.getElementById('openMapButton');
        
        // Éléments de filtrage du tableau
        const tableFilter = document.getElementById('tableFilter');
        const statusFilter = document.getElementById('statusFilter');
        const typeFilter = document.getElementById('typeFilter');
        const clearFilterButton = document.getElementById('clearFilter');
        
        // Éléments pour les filtres avancés
        const addFilterBtn = document.getElementById('add-filter-btn');
        const filterForm = document.getElementById('filter-form');
        const filterField = document.getElementById('filter-field');
        const filterOperator = document.getElementById('filter-operator');
        const filterValue = document.getElementById('filter-value');
        const applyFilterBtn = document.getElementById('apply-filter-btn');
        const cancelFilterBtn = document.getElementById('cancel-filter-btn');
        const activeFilters = document.getElementById('active-filters');
        const clearAllFiltersBtn = document.getElementById('clear-all-filters-btn');
        
        // Variable pour stocker les géocaches sélectionnées
        let selectedGeocaches = [];
        
        // Variable pour stocker les filtres actifs
        let activeFiltersList = [];
        
        // Définitions des opérateurs par type de champ
        const operatorsByFieldType = {
            numeric: [
                { value: "eq", label: "Égal à" },
                { value: "neq", label: "Différent de" },
                { value: "gt", label: "Supérieur à" },
                { value: "gte", label: "Supérieur ou égal à" },
                { value: "lt", label: "Inférieur à" },
                { value: "lte", label: "Inférieur ou égal à" }
            ],
            categorical: [
                { value: "eq", label: "Égal à" },
                { value: "neq", label: "Différent de" },
                { value: "in", label: "Parmi" }
            ]
        };
        
        // Définition des champs et leurs types
        const fieldDefinitions = {
            difficulty: { type: "numeric", label: "Difficulté", values: [1, 1.5, 2, 2.5, 3, 3.5, 4, 4.5, 5] },
            terrain: { type: "numeric", label: "Terrain", values: [1, 1.5, 2, 2.5, 3, 3.5, 4, 4.5, 5] },
            cache_type: { type: "categorical", label: "Type", values: [] }, // Valeurs remplies dynamiquement
            solved: { 
                type: "categorical", 
                label: "Statut", 
                values: [
                    { value: "solved", label: "Résolue" },
                    { value: "not_solved", label: "Non résolue" },
                    { value: "ongoing", label: "En cours" }
                ] 
            },
            size: { 
                type: "categorical", 
                label: "Taille", 
                values: [
                    { value: "Micro", label: "Micro" },
                    { value: "Small", label: "Petite" },
                    { value: "Regular", label: "Normale" },
                    { value: "Large", label: "Grande" },
                    { value: "Other", label: "Autre" }
                ],
                caseSensitive: false // Indiquer que ce champ doit être comparé sans tenir compte de la casse
            },
            favorites_count: { type: "numeric", label: "Favoris", values: [] }, // Valeurs générées dynamiquement
            logs_count: { type: "numeric", label: "Logs", values: [] } // Valeurs générées dynamiquement
        };
        
        // Fonction pour obtenir les références aux éléments des modales dans le conteneur global
        function getModalElements() {
            const modalContainer = window.parent.document.getElementById('modals-container');
            if (!modalContainer) return null;
            
            return {
                // Éléments pour la suppression multiple
                deleteSelectedButton: document.getElementById('delete-selected-btn-{{ zone_id }}'),
                selectedCountElement: document.getElementById('selected-count-container-{{ zone_id }}'),
                deleteMultipleModal: modalContainer.querySelector('#deleteMultipleModal-{{ zone_id }}'),
                geocachesCountToDelete: modalContainer.querySelector('#deleteMultipleModal-{{ zone_id }} .geocaches-count-to-delete'),
                closeDeleteMultipleModal: modalContainer.querySelector('#deleteMultipleModal-{{ zone_id }} .close-delete-multiple-modal'),
                cancelDeleteMultiple: modalContainer.querySelector('#deleteMultipleModal-{{ zone_id }} .cancel-delete-multiple'),
                confirmDeleteMultiple: modalContainer.querySelector('#deleteMultipleModal-{{ zone_id }} .confirm-delete-multiple'),
                deleteLoadingIndicator: modalContainer.querySelector('#deleteMultipleModal-{{ zone_id }} .delete-loading-indicator'),
        
        // Éléments pour l'importation GPX
                importGpxButton: document.getElementById('importGpxButton'),
                importGpxModal: modalContainer.querySelector('#importGpxModal-{{ zone_id }}'),
                closeImportModal: modalContainer.querySelector('#importGpxModal-{{ zone_id }} #closeImportModal'),
                cancelImport: modalContainer.querySelector('#importGpxModal-{{ zone_id }} #cancelImport'),
                importGpxForm: modalContainer.querySelector('#importGpxModal-{{ zone_id }} #importGpxForm'),
                importLoadingIndicator: modalContainer.querySelector('#importGpxModal-{{ zone_id }} .import-loading-indicator'),
                importProgress: modalContainer.querySelector('#importGpxModal-{{ zone_id }} #importProgress'),
                importProgressBar: modalContainer.querySelector('#importGpxModal-{{ zone_id }} #importProgressBar'),
                importProgressText: modalContainer.querySelector('#importGpxModal-{{ zone_id }} #importProgressText'),
                importMessage: modalContainer.querySelector('#importGpxModal-{{ zone_id }} #importMessage'),
                copyToZoneModal: modalContainer.querySelector('#copyToZoneModal-{{ zone_id }}'),
                targetZoneSelect: modalContainer.querySelector('#target-zone-select-{{ zone_id }}'),
                cancelCopyToZone: modalContainer.querySelector('#copyToZoneModal-{{ zone_id }} .cancel-copy-to-zone'),
                confirmCopyToZone: modalContainer.querySelector('#copyToZoneModal-{{ zone_id }} .confirm-copy-to-zone'),
                copyLoadingIndicator: modalContainer.querySelector('#copyToZoneModal-{{ zone_id }} .copy-loading-indicator'),
                geocachesCountToCopy: modalContainer.querySelector('#copyToZoneModal-{{ zone_id }} .geocaches-count-to-copy')
            };
        }

        // Fonction pour initialiser Tabulator
        function initializeTabulator() {
            const tableId = `geocaches-table-{{ zone_id }}`;
            const tableElement = document.getElementById(tableId);
            if (!tableElement) return;

            const apiUrl = tableElement.dataset.apiUrl;
            
            // Détruire l'instance existante si elle existe
            if (window[`tabulator_${tableId}`]) {
                window[`tabulator_${tableId}`].destroy();
            }

            // Créer une nouvelle instance de Tabulator
            window[`tabulator_${tableId}`] = new Tabulator(`#${tableId}`, {
                ajaxURL: apiUrl,
                layout: "fitDataFill",
                height: "100%",
                placeholder: "Aucune géocache trouvée",
                selectable: true, // Activer la sélection de lignes
                selectableRangeMode: "click", // Permettre la sélection par Shift+Click
                // Nous ne voulons pas de pagination par défaut pour avoir toutes les données disponibles
                pagination: false,
                // S'assurer que Tabulator ne limite pas les résultats
                maxHeight: "100%", // Utiliser toute la hauteur disponible
                virtualDom: true, // Activer le DOM virtuel pour de meilleures performances
                layoutColumnsOnNewData: false, // Ne pas recalculer la disposition à chaque mise à jour
                // Garantir que toutes les données sont chargées
                ajaxConfig: {
                    method: "GET",
                },
                // Stocker toutes les données pour nos opérations personnalisées
                ajaxResponse: function(url, params, response) {
                    // Stocker les données complètes dans une variable accessible
                    window[`allGeocachesData_${tableId}`] = response;
                    console.log(`Chargement de ${response.length} géocaches dans le tableau.`);
                    return response;
                },
                columns: [
                    { title: "GC Code", field: "gc_code", headerSort: true },
                    { title: "Nom", field: "name", headerSort: true },
                    { title: "Type", field: "cache_type", headerSort: true },
                    { title: "Difficulté", field: "difficulty", headerSort: true },
                    { title: "Terrain", field: "terrain", headerSort: true },
                    { title: "Taille", field: "size", headerSort: true },
                    { title: "Favoris", field: "favorites_count", headerSort: true },
                    { title: "Logs", field: "logs_count", headerSort: true },
                    { title: "Statut", field: "solved", headerSort: true,
                        formatter: function(cell) {
                            const value = cell.getValue();
                            switch(value) {
                                case 'solved':
                                    return '<span class="text-green-500">✓ Résolue</span>';
                                case 'not_solved':
                                    return '<span class="text-red-500">✗ Non résolue</span>';
                                case 'ongoing':
                                    return '<span class="text-yellow-500">⟳ En cours</span>';
                                default:
                                    return '<span class="text-gray-500">-</span>';
                            }
                        }
                    },
                    { title: "Actions", field: "id", headerSort: false,
                        formatter: function(cell) {
                            const row = cell.getRow();
                            const data = row.getData();
                            const geocacheId = data.id;
                            const gcCode = data.gc_code;
                            const name = data.name;
                            
                            // Échapper les caractères spéciaux pour JavaScript
                            const escapedGcCode = gcCode.replace(/['\\]/g, '\\$&');
                            const escapedName = name.replace(/['\\]/g, '\\$&');
                            
                            return `<button 
                                class="details-button"
                                onclick="window.parent.postMessage({ 
                                    type: 'openGeocacheDetails', 
                                    geocacheId: ${geocacheId},
                                    gcCode: '${escapedGcCode}',
                                    name: '${escapedName}'
                                }, '*')"
                            >
                                Détails
                            </button>
                            <button 
                                class="delete-button"
                                onclick="window.deleteGeocache(${geocacheId}, '${escapedGcCode}')"
                            >
                                Supprimer
                            </button>`;
                        }
                    }
                ],
                initialComplete: function() {
                    // Remplir dynamiquement le filtre de type avec les valeurs uniques de la colonne
                    const table = window[`tabulator_${tableId}`];
                    const allData = table.getData();
                    console.log(`Tableau initialisé avec ${allData.length} géocaches au total.`);
                    
                    const uniqueTypes = [...new Set(allData.map(row => row.cache_type))].filter(Boolean).sort();
                    
                    // Vider d'abord les options existantes sauf la première
                    while(typeFilter.options.length > 1) {
                        typeFilter.remove(1);
                    }
                    
                    // Ajouter les types uniques comme options
                    uniqueTypes.forEach(type => {
                        const option = document.createElement('option');
                        option.value = type;
                        option.textContent = type;
                        typeFilter.appendChild(option);
                    });
                    
                    // Remplir également les valeurs pour le filtre avancé de type
                    fieldDefinitions.cache_type.values = uniqueTypes.map(type => ({ value: type, label: type }));
                    
                    // Collecter les tailles uniques pour le filtre de taille
                    const uniqueSizes = [...new Set(allData.map(row => row.size))].filter(Boolean);
                    if (uniqueSizes.length > 0) {
                        // Remplacer les valeurs prédéfinies par les valeurs réelles trouvées dans les données
                        fieldDefinitions.size.values = uniqueSizes.map(size => ({ value: size, label: size }));
                        console.log("Tailles uniques trouvées:", uniqueSizes);
                    }
                    
                    // Déterminer les plages pour les favoris et logs
                    if (allData.length > 0) {
                        const maxFavorites = Math.max(...allData.map(row => row.favorites_count || 0));
                        const maxLogs = Math.max(...allData.map(row => row.logs_count || 0));
                        
                        // Générer des valeurs sensibles pour ces champs
                        fieldDefinitions.favorites_count.values = [0, 5, 10, 25, 50, 100, 200, 500, 1000].filter(v => v <= maxFavorites * 1.2);
                        fieldDefinitions.logs_count.values = [0, 10, 25, 50, 100, 250, 500, 1000, 2000].filter(v => v <= maxLogs * 1.2);
                    }
                },
                rowSelectionChanged: function(data, rows) {
                    // Mettre à jour les géocaches sélectionnées
                    selectedGeocaches = data;
                    
                    // Mettre à jour le compteur et le bouton de suppression
                    updateSelectionCount();
                }
            });
            
            return window[`tabulator_${tableId}`];
        }

        // Fonction pour mettre à jour le compteur de sélection et l'état du bouton de suppression
        function updateSelectionCount() {
            const count = selectedGeocaches.length;
            const elements = getModalElements();
            if (!elements) return;
            
            const { selectedCountElement, deleteSelectedButton } = elements;
            
            if (count > 0 && selectedCountElement) {
                selectedCountElement.textContent = count;
                selectedCountElement.classList.remove('hidden');
            } else if (selectedCountElement) {
                selectedCountElement.classList.add('hidden');
            }
        }

        // Fonction pour mettre à jour les opérateurs disponibles en fonction du champ sélectionné
        function updateOperators() {
            const fieldName = filterField.value;
            const fieldType = fieldDefinitions[fieldName].type;
            
            // Vider les options existantes
            filterOperator.innerHTML = '';
            
            // Ajouter les nouvelles options
            operatorsByFieldType[fieldType].forEach(op => {
                const option = document.createElement('option');
                option.value = op.value;
                option.textContent = op.label;
                filterOperator.appendChild(option);
            });
            
            // Mettre à jour les valeurs
            updateValues();
        }
        
        // Fonction pour mettre à jour les valeurs disponibles en fonction du champ et de l'opérateur sélectionnés
        function updateValues() {
            const fieldName = filterField.value;
            const operatorValue = filterOperator.value;
            const fieldDef = fieldDefinitions[fieldName];
            
            // Vider les options existantes
            filterValue.innerHTML = '';
            
            // Si l'opérateur est "in", afficher une interface de sélection multiple
            if (operatorValue === "in") {
                // Pour l'instant, nous utilisons un select simple avec des instructions
                const instruction = document.createElement('option');
                instruction.value = "";
                instruction.textContent = "Sélectionnez plusieurs valeurs (Ctrl+clic)";
                instruction.disabled = true;
                instruction.selected = true;
                filterValue.appendChild(instruction);
                
                // Rendre le select multiple
                filterValue.setAttribute('multiple', 'multiple');
                filterValue.setAttribute('size', '4');
            } else {
                // Rendre le select simple
                filterValue.removeAttribute('multiple');
                filterValue.removeAttribute('size');
            }
            
            // Ajouter les valeurs
            if (fieldDef.values.length > 0) {
                // Si les valeurs sont prédéfinies
                fieldDef.values.forEach(val => {
                    const option = document.createElement('option');
                    if (typeof val === 'object') {
                        option.value = val.value;
                        option.textContent = val.label;
                    } else {
                        option.value = val;
                        option.textContent = val;
                    }
                    filterValue.appendChild(option);
                });
            } else {
                // Si les valeurs doivent être générées dynamiquement
                if (fieldName === 'favorites_count' || fieldName === 'logs_count') {
                    // Pour les compteurs, générer des valeurs de 0 à 100 par incréments de 5
                    for (let i = 0; i <= 100; i += 5) {
                        const option = document.createElement('option');
                        option.value = i;
                        option.textContent = i;
                        filterValue.appendChild(option);
                    }
                }
                // Pour cache_type, les valeurs sont déjà générées lors de l'initialisation du tableau
            }
        }
        
        // Fonction pour supprimer tous les filtres actifs
        function clearAllFilters() {
            // Vider la liste des filtres actifs
            activeFiltersList = [];
            
            // Supprimer tous les éléments visuels
            activeFilters.innerHTML = '';
            
            // Masquer le bouton de suppression totale
            clearAllFiltersBtn.classList.add('hidden');
            
            // Appliquer les filtres (ou plutôt, les supprimer tous)
            applyFilters();
        }
        
        // Fonction pour ajouter un filtre actif
        function addActiveFilter() {
            const fieldName = filterField.value;
            const operatorValue = filterOperator.value;
            const fieldDef = fieldDefinitions[fieldName];
            let filterValueDisplay;
            let filterValueData;
            
            // Récupérer la valeur sélectionnée
            if (operatorValue === "in" && filterValue.multiple) {
                // Pour la sélection multiple
                const selectedOptions = Array.from(filterValue.selectedOptions);
                if (selectedOptions.length === 0) return; // Ne rien faire si aucune option n'est sélectionnée
                
                filterValueData = selectedOptions.map(opt => opt.value);
                
                // Créer une représentation visuelle des valeurs sélectionnées
                filterValueDisplay = selectedOptions.map(opt => opt.textContent).join(", ");
            } else {
                // Pour la sélection simple
                filterValueData = filterValue.value;
                filterValueDisplay = filterValue.options[filterValue.selectedIndex].textContent;
            }
            
            // S'assurer que la valeur est du bon type
            if (fieldDef.type === "numeric" && !Array.isArray(filterValueData)) {
                // Convertir explicitement en nombre
                filterValueData = filterValueData.toString();
            }
            
            // Trouver le label de l'opérateur
            const operatorObj = operatorsByFieldType[fieldDef.type].find(op => op.value === operatorValue);
            const operatorLabel = operatorObj ? operatorObj.label : operatorValue;
            
            // Créer un objet filtre
            const filter = {
                id: Date.now(), // Identifiant unique
                field: fieldName,
                operator: operatorValue,
                value: filterValueData,
                displayText: `${fieldDef.label} ${operatorLabel} ${filterValueDisplay}`
            };
            
            console.log("Nouveau filtre créé:", filter);
            
            // Ajouter à la liste des filtres actifs
            activeFiltersList.push(filter);
            
            // Créer l'élément visuel du filtre
            const filterElement = document.createElement('div');
            filterElement.className = 'inline-flex items-center bg-blue-600 text-white text-xs rounded-full px-3 py-1';
            filterElement.dataset.filterId = filter.id;
            filterElement.innerHTML = `
                <span class="mr-1">${filter.displayText}</span>
                <button class="remove-filter text-white hover:text-red-200" data-filter-id="${filter.id}">
                    <i class="fas fa-times"></i>
                </button>
            `;
            
            // Ajouter l'élément à la liste des filtres actifs
            activeFilters.appendChild(filterElement);
            
            // Cacher le formulaire d'ajout de filtre
            filterForm.classList.add('hidden');
            
            // Afficher le bouton de suppression totale s'il y a au moins un filtre
            clearAllFiltersBtn.classList.remove('hidden');
            
            // Appliquer les filtres
            applyFilters();
        }
        
        // Fonction pour supprimer un filtre actif
        function removeFilter(filterId) {
            // Supprimer de la liste des filtres actifs
            activeFiltersList = activeFiltersList.filter(f => f.id.toString() !== filterId.toString());
            
            // Supprimer l'élément visuel
            const filterElement = activeFilters.querySelector(`[data-filter-id="${filterId}"]`);
            if (filterElement) {
                filterElement.remove();
            }
            
            // Masquer le bouton de suppression totale s'il n'y a plus de filtres
            if (activeFiltersList.length === 0) {
                clearAllFiltersBtn.classList.add('hidden');
            }
            
            // Appliquer les filtres mis à jour
            applyFilters();
        }
        
        // Fonction pour appliquer tous les filtres actifs
        function applyFilters() {
            const tableId = `geocaches-table-{{ zone_id }}`;
            const table = window[`tabulator_${tableId}`];
            if (!table) return;
            
            // Obtenir les valeurs des filtres simples (recherche, statut, type)
            const textFilter = tableFilter.value.toLowerCase();
            const statusValue = statusFilter.value;
            const typeValue = typeFilter.value;
            
            // Si aucun filtre actif et aucun filtre simple, supprimer tous les filtres
            if (activeFiltersList.length === 0 && !textFilter && !statusValue && !typeValue) {
                console.log("Aucun filtre actif, affichage de toutes les données");
                table.clearFilter();
                
                // Vérifier le nombre réel de lignes affichées
                setTimeout(() => {
                    const visibleRows = table.getRows("visible");
                    console.log(`Après suppression des filtres: ${visibleRows.length} géocaches visibles`);
                }, 50);
                
                return;
            }
            
            // Obtenir toutes les données pour des logs de diagnostic
            const allData = window[`allGeocachesData_${tableId}`] || table.getData();
            
            // Appliquer tous les filtres
            table.setFilter(function(data) {
                let matchesAllFilters = true;
                
                // Vérifier les filtres simples
                // Filtre textuel
                if (textFilter) {
                    const textMatch = (
                        (data.gc_code && data.gc_code.toLowerCase().includes(textFilter)) ||
                        (data.name && data.name.toLowerCase().includes(textFilter)) ||
                        (data.cache_type && data.cache_type.toLowerCase().includes(textFilter))
                    );
                    if (!textMatch) matchesAllFilters = false;
                }
                
                // Filtre de statut
                if (statusValue && matchesAllFilters) {
                    const statusMatch = data.solved === statusValue;
                    if (!statusMatch) matchesAllFilters = false;
                }
                
                // Filtre de type
                if (typeValue && matchesAllFilters) {
                    const typeMatch = data.cache_type === typeValue;
                    if (!typeMatch) matchesAllFilters = false;
                }
                
                // Vérifier les filtres avancés
                for (const filter of activeFiltersList) {
                    if (!matchesAllFilters) break; // Sortir si déjà non correspondant
                    
                    const fieldValue = data[filter.field];
                    const filterValue = filter.value;
                    const fieldDef = fieldDefinitions[filter.field];
                    
                    // Log pour débogage
                    console.log(`Comparaison pour ${filter.field}: valeur dans données = "${fieldValue}" (${typeof fieldValue}), valeur de filtre = "${filterValue}" (${typeof filterValue})`);
                    
                    // Vérifier si la valeur existe
                    if (fieldValue === undefined || fieldValue === null) {
                        matchesAllFilters = false;
                        continue;
                    }
                    
                    // Convertir les valeurs en nombres pour les champs numériques
                    let dataValue = fieldValue;
                    let comparisonValue = filterValue;
                    
                    if (fieldDef?.type === "numeric") {
                        dataValue = parseFloat(dataValue);
                        comparisonValue = parseFloat(comparisonValue);
                        
                        // Vérifier si la conversion a réussi
                        if (isNaN(dataValue) || isNaN(comparisonValue)) {
                            console.warn(`Conversion en nombre échouée pour ${filter.field}: ${dataValue} ou ${comparisonValue}`);
                            matchesAllFilters = false;
                            continue;
                        }
                    }
                    
                    // Pour les champs insensibles à la casse, convertir en minuscules
                    if (fieldDef?.caseSensitive === false) {
                        dataValue = typeof dataValue === 'string' ? dataValue.toLowerCase() : dataValue;
                        comparisonValue = typeof comparisonValue === 'string' ? comparisonValue.toLowerCase() : comparisonValue;
                    }
                    
                    // Appliquer l'opérateur approprié
                    switch (filter.operator) {
                        case "eq":
                            matchesAllFilters = dataValue === comparisonValue;
                            break;
                        case "neq":
                            matchesAllFilters = dataValue !== comparisonValue;
                            break;
                        case "gt":
                            matchesAllFilters = dataValue > comparisonValue;
                            break;
                        case "gte":
                            matchesAllFilters = dataValue >= comparisonValue;
                            break;
                        case "lt":
                            matchesAllFilters = dataValue < comparisonValue;
                            break;
                        case "lte":
                            matchesAllFilters = dataValue <= comparisonValue;
                            break;
                        case "in":
                            // Pour les opérateurs "in" (parmi)
                            if (Array.isArray(comparisonValue)) {
                                if (fieldDef?.caseSensitive === false && typeof dataValue === 'string') {
                                    // Cas insensible à la casse, convertir toutes les valeurs en minuscules
                                    const lowerCaseValues = comparisonValue.map(v => typeof v === 'string' ? v.toLowerCase() : v.toString().toLowerCase());
                                    matchesAllFilters = lowerCaseValues.includes(dataValue);
                                } else {
                                    // Cas normal, convertir en strings pour la comparaison si nécessaire
                                    const stringComparisonValues = comparisonValue.map(v => v.toString());
                                    matchesAllFilters = stringComparisonValues.includes(dataValue.toString());
                                }
                            } else {
                                matchesAllFilters = dataValue.toString() === comparisonValue.toString();
                            }
                            break;
                        default:
                            console.warn(`Opérateur non reconnu: ${filter.operator}`);
                            matchesAllFilters = true;
                    }
                    
                    // Log pour débogage
                    console.log(`Résultat de comparaison: ${matchesAllFilters} (opérateur: ${filter.operator})`);
                }
                
                return matchesAllFilters;
            });
            
            // Vérification et diagnostic après filtrage
            setTimeout(() => {
                const visibleRows = table.getRows("visible");
                console.log(`Après filtrage avancé: ${visibleRows.length} géocaches visibles`);
                
                // Log des filtres actifs pour diagnostic
                console.log("Filtres actifs:", activeFiltersList);
                
                // Vérification manuelle pour le débogage
                if (visibleRows.length === 0 && activeFiltersList.length > 0) {
                    console.log("Aucun résultat trouvé. Vérification manuelle des correspondances...");
                    
                    // Vérifier manuellement combien d'éléments correspondent aux critères
                    const matches = allData.filter(item => {
                        for (const filter of activeFiltersList) {
                            const fieldValue = item[filter.field];
                            if (fieldValue === undefined || fieldValue === null) return false;
                            
                            // Convertir pour les comparaisons numériques
                            let dataValue = fieldValue;
                            let comparisonValue = filter.value;
                            const fieldDef = fieldDefinitions[filter.field];
                            
                            if (fieldDef?.type === "numeric") {
                                dataValue = parseFloat(dataValue);
                                comparisonValue = parseFloat(comparisonValue);
                            }
                            
                            // Pour les champs insensibles à la casse
                            if (fieldDef?.caseSensitive === false) {
                                dataValue = typeof dataValue === 'string' ? dataValue.toLowerCase() : dataValue;
                                comparisonValue = typeof comparisonValue === 'string' ? comparisonValue.toLowerCase() : comparisonValue;
                            }
                            
                            // Pour les filtres d'égalité, qui sont les plus courants
                            if (filter.operator === "eq" && dataValue != comparisonValue) {
                                return false;
                            }
                        }
                        return true;
                    });
                    
                    console.log(`Vérification manuelle: ${matches.length} correspondances trouvées.`);
                    if (matches.length > 0) {
                        console.log("Exemples de correspondances:", matches.slice(0, 3));
                    }
                }
            }, 100);
        }

        // Fonction pour ouvrir le modal de confirmation de suppression multiple
        function openDeleteMultipleModal() {
            const elements = getModalElements();
            if (!elements) return;
            
            const { deleteMultipleModal, geocachesCountToDelete, deleteConfirmText } = elements;
            
            // Obtenir toutes les géocaches qui correspondent aux filtres actuels
            const tableId = `geocaches-table-{{ zone_id }}`;
            const table = window[`tabulator_${tableId}`];
            
            if (!table) return;
            
            // Récupérer toutes les données
            const allData = window[`allGeocachesData_${tableId}`] || table.getData();
            
            // Obtenir les valeurs des filtres simples (recherche, statut, type)
            const textFilter = tableFilter.value.toLowerCase();
            const statusValue = statusFilter.value;
            const typeValue = typeFilter.value;
            
            // Filtrer manuellement les données selon les mêmes critères que applyFilters()
            const geocachesToDelete = allData.filter(data => {
                let matchesAllFilters = true;
                
                // Vérifier les filtres simples
                // Filtre textuel
                if (textFilter) {
                    const textMatch = (
                        (data.gc_code && data.gc_code.toLowerCase().includes(textFilter)) ||
                        (data.name && data.name.toLowerCase().includes(textFilter)) ||
                        (data.cache_type && data.cache_type.toLowerCase().includes(textFilter))
                    );
                    if (!textMatch) matchesAllFilters = false;
                }
                
                // Filtre de statut
                if (statusValue && matchesAllFilters) {
                    const statusMatch = data.solved === statusValue;
                    if (!statusMatch) matchesAllFilters = false;
                }
                
                // Filtre de type
                if (typeValue && matchesAllFilters) {
                    const typeMatch = data.cache_type === typeValue;
                    if (!typeMatch) matchesAllFilters = false;
                }
                
                // Vérifier les filtres avancés
                for (const filter of activeFiltersList) {
                    if (!matchesAllFilters) break; // Sortir si déjà non correspondant
                    
                    const fieldValue = data[filter.field];
                    const filterValue = filter.value;
                    const fieldDef = fieldDefinitions[filter.field];
                    
                    // Vérifier si la valeur existe
                    if (fieldValue === undefined || fieldValue === null) {
                        matchesAllFilters = false;
                        continue;
                    }
                    
                    // Convertir les valeurs en nombres pour les champs numériques
                    let dataValue = fieldValue;
                    let comparisonValue = filterValue;
                    
                    if (fieldDef?.type === "numeric") {
                        dataValue = parseFloat(dataValue);
                        comparisonValue = parseFloat(comparisonValue);
                        
                        // Vérifier si la conversion a réussi
                        if (isNaN(dataValue) || isNaN(comparisonValue)) {
                            matchesAllFilters = false;
                            continue;
                        }
                    }
                    
                    // Pour les champs insensibles à la casse, convertir en minuscules
                    if (fieldDef?.caseSensitive === false) {
                        dataValue = typeof dataValue === 'string' ? dataValue.toLowerCase() : dataValue;
                        comparisonValue = typeof comparisonValue === 'string' ? comparisonValue.toLowerCase() : comparisonValue;
                    }
                    
                    // Appliquer l'opérateur approprié
                    switch (filter.operator) {
                        case "eq":
                            matchesAllFilters = dataValue === comparisonValue;
                            break;
                        case "neq":
                            matchesAllFilters = dataValue !== comparisonValue;
                            break;
                        case "gt":
                            matchesAllFilters = dataValue > comparisonValue;
                            break;
                        case "gte":
                            matchesAllFilters = dataValue >= comparisonValue;
                            break;
                        case "lt":
                            matchesAllFilters = dataValue < comparisonValue;
                            break;
                        case "lte":
                            matchesAllFilters = dataValue <= comparisonValue;
                            break;
                        case "in":
                            // Pour les opérateurs "in" (parmi)
                            if (Array.isArray(comparisonValue)) {
                                if (fieldDef?.caseSensitive === false && typeof dataValue === 'string') {
                                    // Cas insensible à la casse, convertir toutes les valeurs en minuscules
                                    const lowerCaseValues = comparisonValue.map(v => typeof v === 'string' ? v.toLowerCase() : v.toString().toLowerCase());
                                    matchesAllFilters = lowerCaseValues.includes(dataValue);
                                } else {
                                    // Cas normal, convertir en strings pour la comparaison si nécessaire
                                    const stringComparisonValues = comparisonValue.map(v => v.toString());
                                    matchesAllFilters = stringComparisonValues.includes(dataValue.toString());
                                }
                            } else {
                                matchesAllFilters = dataValue.toString() === comparisonValue.toString();
                            }
                            break;
                        default:
                            matchesAllFilters = true;
                    }
                }
                
                return matchesAllFilters;
            });
            
            console.log(`Sélection manuelle de ${geocachesToDelete.length} géocaches filtrées sur un total de ${allData.length}.`);
            
            // Vérifier s'il y a des géocaches correspondant aux filtres
            if (!geocachesToDelete || geocachesToDelete.length === 0) {
                alert("Aucune géocache ne correspond aux filtres actuels. Veuillez ajuster vos filtres.");
                return;
            }
            
            // Stocker les géocaches pour la suppression
            selectedGeocaches = geocachesToDelete;
            
            if (geocachesCountToDelete) {
                geocachesCountToDelete.textContent = selectedGeocaches.length;
            }
            
            if (deleteConfirmText) {
                deleteConfirmText.textContent = `Êtes-vous sûr de vouloir supprimer ${selectedGeocaches.length} géocaches filtrées ?`;
            }
            
            if (deleteMultipleModal) {
                deleteMultipleModal.classList.remove('hidden');
            }
        }

        // Fonction pour ouvrir le modal de confirmation de suppression inverse (garder les filtrées, supprimer les autres)
        function openKeepFilteredModal() {
            const elements = getModalElements();
            if (!elements) return;
            
            const { deleteMultipleModal, geocachesCountToDelete, deleteConfirmText } = elements;
            
            // Obtenir toutes les géocaches qui correspondent aux filtres actuels
            const tableId = `geocaches-table-{{ zone_id }}`;
            const table = window[`tabulator_${tableId}`];
            
            if (!table) return;
            
            // Récupérer toutes les données
            const allData = window[`allGeocachesData_${tableId}`] || table.getData();
            
            // Obtenir les valeurs des filtres simples (recherche, statut, type)
            const textFilter = tableFilter.value.toLowerCase();
            const statusValue = statusFilter.value;
            const typeValue = typeFilter.value;
            
            // Filtrer manuellement les données selon les mêmes critères que applyFilters()
            const geocachesToKeep = allData.filter(data => {
                let matchesAllFilters = true;
                
                // Vérifier les filtres simples
                // Filtre textuel
                if (textFilter) {
                    const textMatch = (
                        (data.gc_code && data.gc_code.toLowerCase().includes(textFilter)) ||
                        (data.name && data.name.toLowerCase().includes(textFilter)) ||
                        (data.cache_type && data.cache_type.toLowerCase().includes(textFilter))
                    );
                    if (!textMatch) matchesAllFilters = false;
                }
                
                // Filtre de statut
                if (statusValue && matchesAllFilters) {
                    const statusMatch = data.solved === statusValue;
                    if (!statusMatch) matchesAllFilters = false;
                }
                
                // Filtre de type
                if (typeValue && matchesAllFilters) {
                    const typeMatch = data.cache_type === typeValue;
                    if (!typeMatch) matchesAllFilters = false;
                }
                
                // Vérifier les filtres avancés
                for (const filter of activeFiltersList) {
                    if (!matchesAllFilters) break; // Sortir si déjà non correspondant
                    
                    const fieldValue = data[filter.field];
                    const filterValue = filter.value;
                    const fieldDef = fieldDefinitions[filter.field];
                    
                    // Vérifier si la valeur existe
                    if (fieldValue === undefined || fieldValue === null) {
                        matchesAllFilters = false;
                        continue;
                    }
                    
                    // Convertir les valeurs en nombres pour les champs numériques
                    let dataValue = fieldValue;
                    let comparisonValue = filterValue;
                    
                    if (fieldDef?.type === "numeric") {
                        dataValue = parseFloat(dataValue);
                        comparisonValue = parseFloat(comparisonValue);
                        
                        // Vérifier si la conversion a réussi
                        if (isNaN(dataValue) || isNaN(comparisonValue)) {
                            matchesAllFilters = false;
                            continue;
                        }
                    }
                    
                    // Pour les champs insensibles à la casse, convertir en minuscules
                    if (fieldDef?.caseSensitive === false) {
                        dataValue = typeof dataValue === 'string' ? dataValue.toLowerCase() : dataValue;
                        comparisonValue = typeof comparisonValue === 'string' ? comparisonValue.toLowerCase() : comparisonValue;
                    }
                    
                    // Appliquer l'opérateur approprié
                    switch (filter.operator) {
                        case "eq":
                            matchesAllFilters = dataValue === comparisonValue;
                            break;
                        case "neq":
                            matchesAllFilters = dataValue !== comparisonValue;
                            break;
                        case "gt":
                            matchesAllFilters = dataValue > comparisonValue;
                            break;
                        case "gte":
                            matchesAllFilters = dataValue >= comparisonValue;
                            break;
                        case "lt":
                            matchesAllFilters = dataValue < comparisonValue;
                            break;
                        case "lte":
                            matchesAllFilters = dataValue <= comparisonValue;
                            break;
                        case "in":
                            // Pour les opérateurs "in" (parmi)
                            if (Array.isArray(comparisonValue)) {
                                if (fieldDef?.caseSensitive === false && typeof dataValue === 'string') {
                                    // Cas insensible à la casse, convertir toutes les valeurs en minuscules
                                    const lowerCaseValues = comparisonValue.map(v => typeof v === 'string' ? v.toLowerCase() : v.toString().toLowerCase());
                                    matchesAllFilters = lowerCaseValues.includes(dataValue);
                                } else {
                                    // Cas normal, convertir en strings pour la comparaison si nécessaire
                                    const stringComparisonValues = comparisonValue.map(v => v.toString());
                                    matchesAllFilters = stringComparisonValues.includes(dataValue.toString());
                                }
                            } else {
                                matchesAllFilters = dataValue.toString() === comparisonValue.toString();
                            }
                            break;
                        default:
                            matchesAllFilters = true;
                    }
                }
                
                return matchesAllFilters;
            });
            
            // Stocker la liste des géocaches à conserver
            const geocachesToDelete = allData.filter(item => !geocachesToKeep.some(keep => keep.id === item.id));
            
            console.log(`Sélection inverse: ${geocachesToDelete.length} géocaches à supprimer sur un total de ${allData.length}. ${geocachesToKeep.length} seront conservées.`);
            
            // Vérifier s'il y a des géocaches à supprimer
            if (!geocachesToDelete || geocachesToDelete.length === 0) {
                alert("Aucune géocache à supprimer. Toutes les géocaches correspondent aux filtres actuels.");
                return;
            }
            
            // Stocker les géocaches pour la suppression
            selectedGeocaches = geocachesToDelete;
            
            if (geocachesCountToDelete) {
                geocachesCountToDelete.textContent = selectedGeocaches.length;
            }
            
            if (deleteConfirmText) {
                deleteConfirmText.textContent = `Êtes-vous sûr de vouloir supprimer ${selectedGeocaches.length} géocaches ? Cette action conservera uniquement les géocaches filtrées (${geocachesToKeep.length} géocaches).`;
            }
            
            if (deleteMultipleModal) {
                deleteMultipleModal.classList.remove('hidden');
            }
        }

        // Fonction pour fermer le modal de confirmation de suppression multiple
        function closeDeleteMultipleModal() {
            const elements = getModalElements();
            if (!elements) return;
            
            const { deleteMultipleModal } = elements;
            
            if (deleteMultipleModal) {
                deleteMultipleModal.classList.add('hidden');
            }
        }

        // Fonction pour supprimer les géocaches sélectionnées
        async function deleteSelectedGeocaches() {
            const elements = getModalElements();
            if (!elements) return;
            
            const { deleteLoadingIndicator } = elements;
            
            // Afficher l'indicateur de chargement
            if (deleteLoadingIndicator) {
                deleteLoadingIndicator.classList.remove('hidden');
            }
            
            let successCount = 0;
            let errorCount = 0;
            
            // Copier la liste des géocaches à supprimer
            const geocachesToDelete = [...selectedGeocaches];
            
            // Supprimer chaque géocache
            for (const geocache of geocachesToDelete) {
                try {
                    const response = await fetch(`/api/geocaches/${geocache.id}`, {
                        method: 'DELETE',
                    });
                    
                    if (response.ok) {
                        successCount++;
                    } else {
                        errorCount++;
                    }
                } catch (error) {
                    console.error('Erreur:', error);
                    errorCount++;
                }
            }
            
            // Mettre à jour le message
            if (successCount > 0) {
                messageDiv.textContent = `${successCount} géocache(s) supprimée(s) avec succès.`;
                messageDiv.className = 'mt-2 text-green-600';
            }
            
            if (errorCount > 0) {
                messageDiv.textContent += ` ${errorCount} géocache(s) n'ont pas pu être supprimées.`;
                messageDiv.className = 'mt-2 text-orange-600';
            }
            
            // Recharger le tableau
            await reloadTable();
            
            // Fermer le modal
            closeDeleteMultipleModal();
            
            // Cacher l'indicateur de chargement
            if (deleteLoadingIndicator) {
                deleteLoadingIndicator.classList.add('hidden');
            }
        }

        // Fonction pour recharger le tableau
        async function reloadTable() {
            // Recharger les données via Tabulator
            const tableId = `geocaches-table-{{ zone_id }}`;
            const table = window[`tabulator_${tableId}`];
            if (table) {
                await table.setData();
            }
        }

        // Initialiser Tabulator au chargement
        const table = initializeTabulator();

        // Fonction pour filtrer le tableau avec le filtre simple
        function filterTable() {
            // Appliquer tous les filtres (simples + avancés)
            applyFilters();
        }

        // Gestionnaires d'événements pour les filtres simples
        tableFilter.addEventListener('input', filterTable);
        statusFilter.addEventListener('change', filterTable);
        typeFilter.addEventListener('change', filterTable);
        
        // Gestionnaire pour effacer le filtre de texte
        clearFilterButton.addEventListener('click', function() {
            tableFilter.value = '';
            filterTable();
        });
        
        // Gestionnaires d'événements pour les filtres avancés
        addFilterBtn.addEventListener('click', function() {
            filterForm.classList.remove('hidden');
            
            // Initialiser le formulaire
            updateOperators();
        });
        
        cancelFilterBtn.addEventListener('click', function() {
            filterForm.classList.add('hidden');
        });
        
        applyFilterBtn.addEventListener('click', addActiveFilter);
        
        // Gestionnaire pour le changement de champ
        filterField.addEventListener('change', updateOperators);
        
        // Gestionnaire pour le changement d'opérateur
        filterOperator.addEventListener('change', updateValues);
        
        // Gestionnaire pour les boutons de suppression de filtre (délégation d'événements)
        activeFilters.addEventListener('click', function(e) {
            const removeButton = e.target.closest('.remove-filter');
            if (removeButton) {
                const filterId = removeButton.dataset.filterId;
                removeFilter(filterId);
            }
        });
        
        // Fonction pour initialiser les gestionnaires d'événements après le déplacement des modales
        function initializeEventListeners() {
            console.log("Initialisation des gestionnaires d'événements pour les modales");
            
            const elements = getModalElements();
            if (!elements) {
                console.warn("Impossible d'obtenir les éléments des modales");
                return;
            }
            
            const { 
                deleteSelectedButton, closeDeleteMultipleModal: closeDeleteModalBtn, cancelDeleteMultiple, 
                confirmDeleteMultiple, deleteMultipleModal, importGpxButton,
                importGpxModal, closeImportModal, cancelImport, importGpxForm,
                copyToZoneModal, targetZoneSelect, cancelCopyToZone, confirmCopyToZone,
                geocachesCountToCopy
            } = elements;

            // Gestionnaire pour le bouton "Copier vers une zone"
            const copyToZoneBtn = document.getElementById('copy-to-zone-btn-{{ zone_id }}');
            if (copyToZoneBtn) {
                copyToZoneBtn.addEventListener('click', openCopyToZoneModal);
            }

            // Gestionnaires pour la modale de copie vers une zone
            if (cancelCopyToZone) {
                cancelCopyToZone.addEventListener('click', closeCopyToZoneModal);
            }

            if (confirmCopyToZone) {
                confirmCopyToZone.addEventListener('click', copyToSelectedZone);
            }

            if (copyToZoneModal) {
                copyToZoneModal.addEventListener('click', function(e) {
                    if (e.target === this) {
                        closeCopyToZoneModal();
                    }
                });
            }

            // Charger la liste des zones au démarrage
            if (targetZoneSelect) {
                loadZonesList();
            }

            // Gestionnaires d'événements pour la suppression multiple
            if (deleteSelectedButton) {
                deleteSelectedButton.addEventListener('click', openDeleteMultipleModal);
            }
            
            if (closeDeleteModalBtn) {
                closeDeleteModalBtn.addEventListener('click', function() {
                    closeDeleteMultipleModal();
                });
            }
            
            if (cancelDeleteMultiple) {
                cancelDeleteMultiple.addEventListener('click', function() {
                    closeDeleteMultipleModal();
                });
            }
            
            if (confirmDeleteMultiple) {
                confirmDeleteMultiple.addEventListener('click', deleteSelectedGeocaches);
            }
            
            // Configurer le modal pour fermer si on clique en dehors
            if (deleteMultipleModal) {
                deleteMultipleModal.addEventListener('click', function(e) {
                    if (e.target === this) {
                        closeDeleteMultipleModal();
                    }
                });
            }
            
            // Gestionnaires d'événements pour l'importation GPX
            if (importGpxButton && importGpxModal) {
                importGpxButton.addEventListener('click', function() {
                    importGpxModal.classList.remove('hidden');
                    if (elements.importMessage) {
                        elements.importMessage.textContent = '';
                        elements.importMessage.className = '';
                    }
                    if (elements.importProgress) {
                        elements.importProgress.classList.add('hidden');
                    }
                    if (elements.importProgressBar) {
                        elements.importProgressBar.style.width = '0%';
                    }
                    if (elements.importProgressText) {
                        elements.importProgressText.textContent = '0%';
                    }
                });
            }
            
            if (closeImportModal && importGpxModal) {
                closeImportModal.addEventListener('click', function() {
                    importGpxModal.classList.add('hidden');
                });
            }
            
            if (cancelImport && importGpxModal) {
                cancelImport.addEventListener('click', function() {
                    importGpxModal.classList.add('hidden');
                });
            }
            
            // Autres gestionnaires d'événements pour l'importation GPX à ajouter si nécessaire
        }
        
        // Attendre un peu pour s'assurer que les modales ont été déplacées
        setTimeout(initializeEventListeners, 100);

        // Gestionnaire d'événements pour la suppression
        window.deleteGeocache = async function(geocacheId, gcCode) {
            if (!confirm(`Êtes-vous sûr de vouloir supprimer la géocache ${gcCode} ?`)) {
                return;
            }

            try {
                const response = await fetch(`/api/geocaches/${geocacheId}`, {
                    method: 'DELETE',
                });
                const data = await response.json();

                if (response.ok) {
                    messageDiv.textContent = data.message;
                    messageDiv.className = 'mt-2 text-green-600';
                    // Recharger le tableau
                    await reloadTable();
                } else {
                    messageDiv.textContent = data.error || 'Une erreur est survenue lors de la suppression';
                    messageDiv.className = 'mt-2 text-red-600';
                }
            } catch (error) {
                console.error('Erreur:', error);
                messageDiv.textContent = 'Une erreur est survenue lors de la communication avec le serveur';
                messageDiv.className = 'mt-2 text-red-600';
            }
        };

        // Gestionnaire d'événements pour l'ajout de géocaches
        form.addEventListener('submit', async function(event) {
            event.preventDefault();

            try {
                // Afficher l'indicateur de chargement
                loadingIndicator.classList.remove('hidden');
                spinner.style.display = 'block';
                messageDiv.textContent = '';
                messageDiv.className = 'mt-2';
                submitButton.disabled = true;
                
                // Préparer les données du formulaire
                const formData = new FormData(form);
                
                // Envoyer la requête
                const response = await fetch('/api/geocaches/add', {
                    method: 'POST',
                    body: formData
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    // Afficher le message de succès
                    messageDiv.textContent = 'Géocache ajoutée avec succès !';
                    messageDiv.className = 'mt-2 text-green-600';
                    
                    // Réinitialiser le formulaire
                    form.reset();

                    // Recharger le tableau
                    await reloadTable();

                    // Ouvrir la page de détails de la nouvelle géocache
                    const apiUrl = window.API_BASE_URL || '';
                    const detailsUrl = `${apiUrl}/geocaches/${data.id}/details-panel`;
                    window.parent.postMessage({
                        type: 'openGeocacheDetails',
                        geocacheId: data.id,
                        containerId: window.currentContainerId,
                        detailsUrl: detailsUrl
                    }, '*');
                } else {
                    // Afficher le message d'erreur
                    messageDiv.textContent = data.error || 'Une erreur est survenue';
                    messageDiv.className = 'mt-2 text-red-600';
                }
            } catch (error) {
                console.error('Erreur:', error);
                messageDiv.textContent = 'Une erreur est survenue lors de la communication avec le serveur';
                messageDiv.className = 'mt-2 text-red-600';
            } finally {
                // Cacher l'indicateur de chargement
                loadingIndicator.classList.add('hidden');
                spinner.style.display = 'none';
                submitButton.disabled = false;
            }
        });
        
        // Ajouter le gestionnaire pour le formulaire d'importation GPX
        setTimeout(function() {
            const elements = getModalElements();
            if (!elements || !elements.importGpxForm) return;
            
            const { 
                importGpxForm, importLoadingIndicator, importProgress,
                importMessage, importProgressBar, importProgressText 
            } = elements;
        
        importGpxForm.addEventListener('submit', async function(event) {
            event.preventDefault();
            
            try {
                // Afficher l'indicateur de chargement
                importLoadingIndicator.classList.remove('hidden');
                importProgress.classList.remove('hidden');
                importMessage.textContent = '';
                importMessage.className = '';
                
                // Préparer les données du formulaire
                const formData = new FormData(importGpxForm);
                
                // Envoyer la requête
                const response = await fetch('/api/geocaches/import-gpx', {
                    method: 'POST',
                    body: formData
                });
                
                // Gérer la réponse en streaming pour la progression
                const reader = response.body.getReader();
                let receivedLength = 0;
                let chunks = [];
                
                while(true) {
                    const {done, value} = await reader.read();
                    
                    if (done) {
                        break;
                    }
                    
                    chunks.push(value);
                    receivedLength += value.length;
                    
                    // Essayer de parser les données reçues jusqu'à présent
                    try {
                        const chunksAll = new Uint8Array(receivedLength);
                        let position = 0;
                        for(let chunk of chunks) {
                            chunksAll.set(chunk, position);
                            position += chunk.length;
                        }
                        
                        const result = new TextDecoder("utf-8").decode(chunksAll);
                        const lines = result.split('\n');
                        
                        for (const line of lines) {
                            if (line.trim()) {
                                try {
                                    const data = JSON.parse(line);
                                    if (data.progress !== undefined) {
                                        importProgressBar.style.width = `${data.progress}%`;
                                        importProgressText.textContent = `${data.progress}%`;
                                    }
                                    if (data.message) {
                                        importMessage.textContent = data.message;
                                        importMessage.className = data.error ? 'text-red-500' : 'text-green-500';
                                    }
                                } catch (e) {
                                    console.error('Erreur de parsing JSON:', e, line);
                                }
                            }
                        }
                    } catch (e) {
                        console.error('Erreur de traitement des chunks:', e);
                    }
                }
                
                // Recharger le tableau une fois l'importation terminée
                await reloadTable();
                
                // Afficher le message final
                importMessage.textContent = 'Importation terminée avec succès !';
                importMessage.className = 'text-green-500';
                
            } catch (error) {
                console.error('Erreur:', error);
                importMessage.textContent = 'Une erreur est survenue lors de l\'importation';
                importMessage.className = 'text-red-500';
            } finally {
                // Cacher l'indicateur de chargement
                importLoadingIndicator.classList.add('hidden');
            }
        });
        }, 200);

        // Gestionnaire pour le bouton de suppression de tous les filtres
        clearAllFiltersBtn.addEventListener('click', clearAllFilters);

        // Fonction pour afficher le formulaire de filtre
        function showFilterForm() {
            filterForm.classList.remove('hidden');
            updateOperators();
        }

        // Fonction pour masquer le formulaire de filtre
        function hideFilterForm() {
            filterForm.classList.add('hidden');
        }

        // Fonction pour ajouter un filtre
        function addFilter() {
            addActiveFilter();
            hideFilterForm();
        }

        // Initialiser les écouteurs d'événements pour les filtres et les boutons d'action
        addFilterBtn.addEventListener('click', showFilterForm);
        applyFilterBtn.addEventListener('click', addFilter);
        cancelFilterBtn.addEventListener('click', hideFilterForm);
        clearAllFiltersBtn.addEventListener('click', clearAllFilters);
        tableFilter.addEventListener('input', filterTable);
        statusFilter.addEventListener('change', filterTable);
        typeFilter.addEventListener('change', filterTable);
        document.querySelector('#delete-selected-btn-{{ zone_id }}').addEventListener('click', openDeleteMultipleModal);
        document.querySelector('#keep-filtered-btn-{{ zone_id }}').addEventListener('click', openKeepFilteredModal);
        document.querySelector('#copy-to-zone-btn-{{ zone_id }}').addEventListener('click', () => openCopyToZoneModal('copy'));
        document.querySelector('#move-to-zone-btn-{{ zone_id }}').addEventListener('click', () => openCopyToZoneModal('move'));
        document.querySelector('#reset-coordinates-btn-{{ zone_id }}').addEventListener('click', resetFilteredCoordinates);
        document.querySelector('#solve-filtered-btn-{{ zone_id }}').addEventListener('click', openMultiSolver);

        // Gestionnaires pour la modale de copie vers une zone
        const elements = getModalElements();
        if (elements) {
            const { cancelCopyToZone, confirmCopyToZone, copyToZoneModal, targetZoneSelect } = elements;
            
            if (cancelCopyToZone) {
                cancelCopyToZone.addEventListener('click', closeCopyToZoneModal);
            }

            if (confirmCopyToZone) {
                confirmCopyToZone.addEventListener('click', copyToSelectedZone);
            }

            if (copyToZoneModal) {
                copyToZoneModal.addEventListener('click', function(e) {
                    if (e.target === this) {
                        closeCopyToZoneModal();
                    }
                });
            }

            // Charger la liste des zones au démarrage
            if (targetZoneSelect) {
                loadZonesList();
            }
        }

        // Fonction pour charger la liste des zones
        async function loadZonesList() {
            const elements = getModalElements();
            if (!elements || !elements.targetZoneSelect) return;

            try {
                const response = await fetch('/api/zones');
                const zones = await response.json();

                // Vider les options existantes sauf la première
                while (elements.targetZoneSelect.options.length > 1) {
                    elements.targetZoneSelect.remove(1);
                }

                // Ajouter les zones comme options
                zones.forEach(zone => {
                    if (zone.id != {{ zone_id }}) { // Exclure la zone actuelle
                        const option = document.createElement('option');
                        option.value = zone.id;
                        option.textContent = zone.name;
                        elements.targetZoneSelect.appendChild(option);
                    }
                });
            } catch (error) {
                console.error('Erreur lors du chargement des zones:', error);
            }
        }

        // Fonction pour ouvrir la modale de copie vers une zone
        function openCopyToZoneModal(action = 'copy') {
            console.log(`Ouverture de la modale pour ${action === 'copy' ? 'copier' : 'déplacer'} les géocaches`);
            
            // Vérifier si la modale est dans le conteneur global
            const modalContainer = window.parent.document.getElementById('modals-container');
            if (!modalContainer) {
                console.error("Conteneur de modales non trouvé dans le document parent");
                return;
            }
            
            // Vérifier si la modale existe dans le conteneur global
            let copyToZoneModal = modalContainer.querySelector('#copyToZoneModal-{{ zone_id }}');
            if (!copyToZoneModal) {
                console.log("Recherche de la modale dans le document local...");
                
                // Vérifier si elle existe dans le document local
                const localModal = document.getElementById('copyToZoneModal-{{ zone_id }}');
                if (localModal) {
                    console.log("Déplacement de la modale vers le conteneur global...");
                    modalContainer.appendChild(localModal.cloneNode(true));
                    localModal.remove();
                    
                    // Récupérer la référence de la modale dans le conteneur global
                    copyToZoneModal = modalContainer.querySelector('#copyToZoneModal-{{ zone_id }}');
                }
            }

            const elements = getModalElements();
            if (!elements) {
                console.error("Éléments de la modale non trouvés");
                return;
            }

            // Mettre à jour les textes selon l'action
            const modalTitle = copyToZoneModal.querySelector('h3');
            const modalText = copyToZoneModal.querySelector('p');
            const confirmButton = copyToZoneModal.querySelector('.confirm-copy-to-zone');
            const closeButton = copyToZoneModal.querySelector('.close-copy-to-zone-modal');
            const cancelButton = copyToZoneModal.querySelector('.cancel-copy-to-zone');
            
            // Réinitialiser les gestionnaires d'événements
            if (closeButton) {
                closeButton.onclick = closeCopyToZoneModal;
            }
            
            if (cancelButton) {
                cancelButton.onclick = closeCopyToZoneModal;
            }
            
            if (confirmButton) {
                confirmButton.onclick = () => {
                    if (action === 'move') {
                        moveToSelectedZone();
                    } else {
                        copyToSelectedZone();
                    }
                };
            }
            
            // Gestionnaire pour fermer en cliquant en dehors
            copyToZoneModal.onclick = function(e) {
                if (e.target === this) {
                    closeCopyToZoneModal();
                }
            };
            
            if (modalTitle) {
                modalTitle.textContent = action === 'copy' ? 'Copier vers une zone' : 'Déplacer vers une zone';
                modalTitle.className = action === 'copy' ? 'text-xl font-bold text-green-500' : 'text-xl font-bold text-yellow-500';
            }
            
            if (modalText) {
                modalText.textContent = `Sélectionnez la zone où ${action === 'copy' ? 'copier' : 'déplacer'} `;
                const countSpan = modalText.querySelector('.geocaches-count-to-copy') || document.createElement('span');
                countSpan.className = 'geocaches-count-to-copy font-semibold';
                modalText.appendChild(countSpan);
                modalText.appendChild(document.createTextNode(' géocaches :'));
            }
            
            if (confirmButton) {
                const buttonSpan = confirmButton.querySelector('span');
                if (buttonSpan) {
                    buttonSpan.textContent = action === 'copy' ? 'Copier' : 'Déplacer';
                }
                confirmButton.className = `confirm-copy-to-zone ${action === 'copy' ? 'bg-green-500 hover:bg-green-700' : 'bg-yellow-500 hover:bg-yellow-700'} text-white font-bold py-2 px-4 rounded inline-flex items-center`;
            }

            // Obtenir les géocaches filtrées comme pour la suppression
            const tableId = `geocaches-table-{{ zone_id }}`;
            const table = window[`tabulator_${tableId}`];
            if (!table) {
                console.error("Table non trouvée");
                return;
            }

            const allData = window[`allGeocachesData_${tableId}`] || table.getData();
            const geocachesToCopy = getFilteredGeocaches(allData);

            if (!geocachesToCopy || geocachesToCopy.length === 0) {
                alert("Aucune géocache ne correspond aux filtres actuels. Veuillez ajuster vos filtres.");
                return;
            }

            // Stocker les géocaches pour la copie
            selectedGeocaches = geocachesToCopy;
            console.log(`${selectedGeocaches.length} géocaches sélectionnées pour ${action === 'copy' ? 'la copie' : 'le déplacement'}`);

            if (elements.geocachesCountToCopy) {
                elements.geocachesCountToCopy.textContent = selectedGeocaches.length;
            }

            // Recharger la liste des zones
            loadZonesList();

            // Afficher la modale
            if (copyToZoneModal) {
                copyToZoneModal.classList.remove('hidden');
                console.log("Modale ouverte avec succès");
            } else {
                console.error("Impossible d'ouvrir la modale : référence non trouvée");
            }
        }

        // Ajouter les gestionnaires d'événements pour les boutons
        document.querySelector('#copy-to-zone-btn-{{ zone_id }}').addEventListener('click', () => openCopyToZoneModal('copy'));
        document.querySelector('#move-to-zone-btn-{{ zone_id }}').addEventListener('click', () => openCopyToZoneModal('move'));

        // Attendre que le DOM soit complètement chargé
        document.addEventListener('DOMContentLoaded', function() {
            console.log("Initialisation des gestionnaires d'événements");
            
            // Initialiser les boutons d'action
            const copyToZoneBtn = document.querySelector('#copy-to-zone-btn-{{ zone_id }}');
            if (copyToZoneBtn) {
                console.log("Ajout du gestionnaire pour le bouton de copie");
                copyToZoneBtn.addEventListener('click', openCopyToZoneModal);
            } else {
                console.error("Bouton de copie non trouvé");
            }

            // Initialiser les éléments de la modale
            const elements = getModalElements();
            if (elements) {
                const { cancelCopyToZone, confirmCopyToZone, copyToZoneModal } = elements;
                
                if (cancelCopyToZone) {
                    cancelCopyToZone.addEventListener('click', closeCopyToZoneModal);
                }

                if (confirmCopyToZone) {
                    confirmCopyToZone.addEventListener('click', copyToSelectedZone);
                }

                if (copyToZoneModal) {
                    copyToZoneModal.addEventListener('click', function(e) {
                        if (e.target === this) {
                            closeCopyToZoneModal();
                        }
                    });
                }
            }
        });

        // Fonction pour fermer la modale de copie vers une zone
        function closeCopyToZoneModal() {
            const elements = getModalElements();
            if (!elements || !elements.copyToZoneModal) return;

            elements.copyToZoneModal.classList.add('hidden');
        }

        // Fonction pour copier les géocaches vers la zone sélectionnée
        async function copyToSelectedZone() {
            const elements = getModalElements();
            if (!elements) return;

            const { targetZoneSelect, copyLoadingIndicator } = elements;

            const targetZoneId = targetZoneSelect.value;
            if (!targetZoneId) {
                alert("Veuillez sélectionner une zone cible.");
                return;
            }

            // Afficher l'indicateur de chargement
            if (copyLoadingIndicator) {
                copyLoadingIndicator.classList.remove('hidden');
            }

            try {
                const response = await fetch('/api/geocaches/copy-to-zone', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        geocache_ids: selectedGeocaches.map(g => g.id),
                        target_zone_id: targetZoneId
                    })
                });

                const data = await response.json();

                if (response.ok) {
                    messageDiv.textContent = `${selectedGeocaches.length} géocache(s) copiée(s) avec succès vers la zone sélectionnée.`;
                    messageDiv.className = 'mt-2 text-green-600';
                } else {
                    throw new Error(data.error || 'Une erreur est survenue lors de la copie');
                }
            } catch (error) {
                console.error('Erreur:', error);
                messageDiv.textContent = error.message || 'Une erreur est survenue lors de la copie des géocaches';
                messageDiv.className = 'mt-2 text-red-600';
            } finally {
                // Cacher l'indicateur de chargement
                if (copyLoadingIndicator) {
                    copyLoadingIndicator.classList.add('hidden');
                }
                // Fermer la modale
                closeCopyToZoneModal();
            }
        }

        // Fonction utilitaire pour obtenir les géocaches filtrées
        function getFilteredGeocaches(allData) {
            // Obtenir les valeurs des filtres simples
            const textFilter = tableFilter.value.toLowerCase();
            const statusValue = statusFilter.value;
            const typeValue = typeFilter.value;

            // Filtrer les données selon les mêmes critères que applyFilters()
            return allData.filter(data => {
                let matchesAllFilters = true;

                // Vérifier les filtres simples
                if (textFilter) {
                    const textMatch = (
                        (data.gc_code && data.gc_code.toLowerCase().includes(textFilter)) ||
                        (data.name && data.name.toLowerCase().includes(textFilter)) ||
                        (data.cache_type && data.cache_type.toLowerCase().includes(textFilter))
                    );
                    if (!textMatch) matchesAllFilters = false;
                }

                if (statusValue && matchesAllFilters) {
                    const statusMatch = data.solved === statusValue;
                    if (!statusMatch) matchesAllFilters = false;
                }

                if (typeValue && matchesAllFilters) {
                    const typeMatch = data.cache_type === typeValue;
                    if (!typeMatch) matchesAllFilters = false;
                }

                // Vérifier les filtres avancés
                for (const filter of activeFiltersList) {
                    if (!matchesAllFilters) break;

                    const fieldValue = data[filter.field];
                    const filterValue = filter.value;
                    const fieldDef = fieldDefinitions[filter.field];

                    if (fieldValue === undefined || fieldValue === null) {
                        matchesAllFilters = false;
                        continue;
                    }

                    let dataValue = fieldValue;
                    let comparisonValue = filterValue;

                    if (fieldDef?.type === "numeric") {
                        dataValue = parseFloat(dataValue);
                        comparisonValue = parseFloat(comparisonValue);

                        if (isNaN(dataValue) || isNaN(comparisonValue)) {
                            matchesAllFilters = false;
                            continue;
                        }
                    }

                    if (fieldDef?.caseSensitive === false) {
                        dataValue = typeof dataValue === 'string' ? dataValue.toLowerCase() : dataValue;
                        comparisonValue = typeof comparisonValue === 'string' ? comparisonValue.toLowerCase() : comparisonValue;
                    }

                    switch (filter.operator) {
                        case "eq":
                            matchesAllFilters = dataValue === comparisonValue;
                            break;
                        case "neq":
                            matchesAllFilters = dataValue !== comparisonValue;
                            break;
                        case "gt":
                            matchesAllFilters = dataValue > comparisonValue;
                            break;
                        case "gte":
                            matchesAllFilters = dataValue >= comparisonValue;
                            break;
                        case "lt":
                            matchesAllFilters = dataValue < comparisonValue;
                            break;
                        case "lte":
                            matchesAllFilters = dataValue <= comparisonValue;
                            break;
                        case "in":
                            if (Array.isArray(comparisonValue)) {
                                if (fieldDef?.caseSensitive === false && typeof dataValue === 'string') {
                                    const lowerCaseValues = comparisonValue.map(v => typeof v === 'string' ? v.toLowerCase() : v.toString().toLowerCase());
                                    matchesAllFilters = lowerCaseValues.includes(dataValue);
                                } else {
                                    const stringComparisonValues = comparisonValue.map(v => v.toString());
                                    matchesAllFilters = stringComparisonValues.includes(dataValue.toString());
                                }
                            } else {
                                matchesAllFilters = dataValue.toString() === comparisonValue.toString();
                            }
                            break;
                        default:
                            matchesAllFilters = true;
                    }
                }

                return matchesAllFilters;
            });
        }

        // Fonctions utilitaires pour afficher les messages
        function showError(message) {
            messageDiv.textContent = message;
            messageDiv.className = 'mt-2 text-red-600';
        }

        function showSuccess(message) {
            messageDiv.textContent = message;
            messageDiv.className = 'mt-2 text-green-600';
        }

        // Fonction pour obtenir les IDs des géocaches filtrées
        function getFilteredGeocacheIds() {
            const tableId = `geocaches-table-{{ zone_id }}`;
            const table = window[`tabulator_${tableId}`];
            if (!table) return [];

            const allData = window[`allGeocachesData_${tableId}`] || table.getData();
            const filteredGeocaches = getFilteredGeocaches(allData);
            return filteredGeocaches.map(g => g.id);
        }

        // Fonction pour rafraîchir le tableau des géocaches
        async function refreshGeocachesTable() {
            const tableId = `geocaches-table-{{ zone_id }}`;
            const table = window[`tabulator_${tableId}`];
            if (table) {
                await table.setData();
            }
        }

        async function moveToSelectedZone() {
            const elements = getModalElements();
            if (!elements) {
                showError('Erreur: éléments de la modale non trouvés');
                return;
            }

            try {
                const selectedZoneId = elements.targetZoneSelect.value;
                if (!selectedZoneId) {
                    showError('Veuillez sélectionner une zone cible');
                    return;
                }

                // Afficher l'indicateur de chargement
                if (elements.copyLoadingIndicator) {
                    elements.copyLoadingIndicator.classList.remove('hidden');
                }

                // Récupérer les IDs des géocaches filtrées
                const geocacheIds = getFilteredGeocacheIds();
                if (geocacheIds.length === 0) {
                    showError('Aucune géocache à déplacer');
                    return;
                }

                // Copier d'abord les géocaches vers la nouvelle zone
                const copyResponse = await fetch('/api/geocaches/copy-to-zone', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        geocache_ids: geocacheIds,
                        target_zone_id: selectedZoneId
                    })
                });

                if (!copyResponse.ok) {
                    throw new Error('Erreur lors de la copie des géocaches vers la nouvelle zone');
                }

                // Supprimer ensuite les géocaches de la zone actuelle
                const deleteResponse = await fetch(`/api/zones/{{ zone_id }}/geocaches`, {
                    method: 'DELETE',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        geocache_ids: geocacheIds
                    })
                });

                if (!deleteResponse.ok) {
                    throw new Error('Erreur lors de la suppression des géocaches de la zone actuelle');
                }

                // Fermer la modale et rafraîchir le tableau
                closeCopyToZoneModal();
                await refreshGeocachesTable();
                showSuccess('Les géocaches ont été déplacées avec succès');

            } catch (error) {
                console.error('Erreur:', error);
                showError('Erreur: ' + error.message);
            } finally {
                // Cacher l'indicateur de chargement
                if (elements.copyLoadingIndicator) {
                    elements.copyLoadingIndicator.classList.add('hidden');
                }
            }
        }

        // Fonction pour ouvrir le multi-solver avec les géocaches filtrées
        function openMultiSolver() {
            console.log("Ouverture du multi-solver pour les géocaches filtrées");
            
            // Obtenir toutes les géocaches qui correspondent aux filtres actuels
            const tableId = `geocaches-table-{{ zone_id }}`;
            const table = window[`tabulator_${tableId}`];
            
            if (!table) return;
            
            // Récupérer toutes les données
            const allData = window[`allGeocachesData_${tableId}`] || table.getData();
            
            // Obtenir les valeurs des filtres simples (recherche, statut, type)
            const textFilter = tableFilter.value.toLowerCase();
            const statusValue = statusFilter.value;
            const typeValue = typeFilter.value;
            
            // Filtrer manuellement les données selon les mêmes critères que applyFilters()
            const filteredGeocaches = allData.filter(data => {
                let matchesAllFilters = true;
                
                // Vérifier les filtres simples
                // Filtre textuel
                if (textFilter) {
                    const textMatch = (
                        (data.gc_code && data.gc_code.toLowerCase().includes(textFilter)) ||
                        (data.name && data.name.toLowerCase().includes(textFilter)) ||
                        (data.cache_type && data.cache_type.toLowerCase().includes(textFilter))
                    );
                    if (!textMatch) matchesAllFilters = false;
                }
                
                // Filtre de statut
                if (statusValue && matchesAllFilters) {
                    const statusMatch = data.solved === statusValue;
                    if (!statusMatch) matchesAllFilters = false;
                }
                
                // Filtre de type
                if (typeValue && matchesAllFilters) {
                    const typeMatch = data.cache_type === typeValue;
                    if (!typeMatch) matchesAllFilters = false;
                }
                
                // Vérifier les filtres avancés
                for (const filter of activeFiltersList) {
                    if (!matchesAllFilters) break; // Sortir si déjà non correspondant
                    
                    const fieldValue = data[filter.field];
                    const filterValue = filter.value;
                    const fieldDef = fieldDefinitions[filter.field];
                    
                    // Vérifier si la valeur existe
                    if (fieldValue === undefined || fieldValue === null) {
                        matchesAllFilters = false;
                        continue;
                    }
                    
                    // Convertir les valeurs en nombres pour les champs numériques
                    let dataValue = fieldValue;
                    let comparisonValue = filterValue;
                    
                    if (fieldDef?.type === "numeric") {
                        dataValue = parseFloat(dataValue);
                        comparisonValue = parseFloat(comparisonValue);
                        
                        // Vérifier si la conversion a réussi
                        if (isNaN(dataValue) || isNaN(comparisonValue)) {
                            matchesAllFilters = false;
                            continue;
                        }
                    }
                    
                    // Pour les champs insensibles à la casse, convertir en minuscules
                    if (fieldDef?.caseSensitive === false) {
                        dataValue = typeof dataValue === 'string' ? dataValue.toLowerCase() : dataValue;
                        comparisonValue = typeof comparisonValue === 'string' ? comparisonValue.toLowerCase() : comparisonValue;
                    }
                    
                    // Appliquer l'opérateur approprié
                    switch (filter.operator) {
                        case "eq":
                            matchesAllFilters = dataValue === comparisonValue;
                            break;
                        case "neq":
                            matchesAllFilters = dataValue !== comparisonValue;
                            break;
                        case "gt":
                            matchesAllFilters = dataValue > comparisonValue;
                            break;
                        case "gte":
                            matchesAllFilters = dataValue >= comparisonValue;
                            break;
                        case "lt":
                            matchesAllFilters = dataValue < comparisonValue;
                            break;
                        case "lte":
                            matchesAllFilters = dataValue <= comparisonValue;
                            break;
                        case "in":
                            // Pour les opérateurs "in" (parmi)
                            if (Array.isArray(comparisonValue)) {
                                if (fieldDef?.caseSensitive === false && typeof dataValue === 'string') {
                                    // Cas insensible à la casse, convertir toutes les valeurs en minuscules
                                    const lowerCaseValues = comparisonValue.map(v => typeof v === 'string' ? v.toLowerCase() : v.toString().toLowerCase());
                                    matchesAllFilters = lowerCaseValues.includes(dataValue);
                                } else {
                                    // Cas normal, convertir en strings pour la comparaison si nécessaire
                                    const stringComparisonValues = comparisonValue.map(v => v.toString());
                                    matchesAllFilters = stringComparisonValues.includes(dataValue.toString());
                                }
                            } else {
                                matchesAllFilters = dataValue.toString() === comparisonValue.toString();
                            }
                            break;
                        default:
                            matchesAllFilters = true;
                    }
                }
                
                return matchesAllFilters;
            });
            
            console.log(`Filtrage manuel: ${filteredGeocaches.length} géocaches filtrées sur un total de ${allData.length}.`);
            
            // Vérifier s'il y a des géocaches correspondant aux filtres
            if (!filteredGeocaches || filteredGeocaches.length === 0) {
                alert("Aucune géocache ne correspond aux filtres actuels. Veuillez ajuster vos filtres.");
                return;
            }
            
            // Préparer les données des géocaches pour le multi-solver
            const geocachesData = filteredGeocaches.map(g => ({
                id: g.id,
                gc_code: g.gc_code,
                name: g.name
            }));
            
            console.log("Données des géocaches pour le multi-solver:", geocachesData);
            
            // Encoder les données des géocaches pour les passer via l'URL
            const encodedGeocachesData = encodeURIComponent(JSON.stringify(geocachesData));
            
            // Ouvrir un nouvel onglet avec le multi-solver
            window.parent.postMessage({
                type: 'openMultiSolver',
                geocaches: geocachesData,
                component: {
                    type: 'component',
                    componentName: 'multi-solver',
                    title: `Multi-Solver (${geocachesData.length} géocaches)`,
                    componentState: {
                        url: `/multi-solver`,
                        geocaches: geocachesData // Passer les géocaches directement dans le componentState
                    }
                }
            }, '*');
        }

        // Fonction pour réinitialiser les coordonnées des géocaches filtrées
        function resetFilteredCoordinates() {
            // Obtenir toutes les géocaches qui correspondent aux filtres actuels
            const tableId = `geocaches-table-{{ zone_id }}`;
            const table = window[`tabulator_${tableId}`];
            
            if (!table) return;
            
            // Récupérer toutes les données
            const allData = window[`allGeocachesData_${tableId}`] || table.getData();
            
            // Obtenir les géocaches filtrées
            const filteredGeocaches = getFilteredGeocaches(allData);
            
            if (!filteredGeocaches || filteredGeocaches.length === 0) {
                alert("Aucune géocache ne correspond aux filtres actuels. Veuillez ajuster vos filtres.");
                return;
            }
            
            // Demander confirmation avant de réinitialiser
            if (!confirm(`Êtes-vous sûr de vouloir réinitialiser les coordonnées corrigées de ${filteredGeocaches.length} géocaches ? Cette action supprimera également le statut 'résolu' des géocaches.`)) {
                return;
            }
            
            // Afficher un indicateur de chargement
            showLoadingIndicator();
            
            // Utiliser une approche séquentielle pour réinitialiser chaque géocache individuellement
            const geocacheIds = filteredGeocaches.map(g => g.id);
            let successCount = 0;
            let errorCount = 0;
            let processedCount = 0;
            
            // Fonction pour traiter un géocache à la fois
            const processGeocache = (index) => {
                if (index >= geocacheIds.length) {
                    // Tous les géocaches ont été traités
                    hideLoadingIndicator();
                    alert(`Réinitialisation terminée : ${successCount} géocache(s) réinitialisée(s), ${errorCount} erreur(s).`);
                    refreshGeocachesTable();
                    return;
                }
                
                const geocacheId = geocacheIds[index];
                
                // Utiliser la route individuelle pour réinitialiser
                fetch(`/geocaches/${geocacheId}/coordinates/reset`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                })
                .then(response => {
                    processedCount++;
                    
                    if (response.ok) {
                        successCount++;
                    } else {
                        errorCount++;
                        console.error(`Erreur lors de la réinitialisation de la géocache ${geocacheId}`);
                    }
                    
                    // Traiter la géocache suivante
                    processGeocache(index + 1);
                })
                .catch(error => {
                    processedCount++;
                    errorCount++;
                    console.error(`Erreur lors de la réinitialisation de la géocache ${geocacheId}:`, error);
                    
                    // Continuer avec la suivante malgré l'erreur
                    processGeocache(index + 1);
                });
            };
            
            // Démarrer le traitement avec la première géocache
            processGeocache(0);
        }

        // Fonction pour afficher l'indicateur de chargement
        function showLoadingIndicator() {
            const spinner = document.querySelector('.spinner');
            if (spinner) {
                spinner.style.display = 'block';
            }
        }

        // Fonction pour masquer l'indicateur de chargement
        function hideLoadingIndicator() {
            const spinner = document.querySelector('.spinner');
            if (spinner) {
                spinner.style.display = 'none';
            }
        }
    })();
</script>
