<!-- Template pour l'interface d'un plugin -->
<div class="w-full h-full bg-gray-900 p-6" 
     data-controller="plugin-interface"
     data-plugin-interface-id-value="{{ plugin.params.get('geocacheId', 'default') }}"
     data-plugin-name="{{ plugin.name }}"
     hx-ext="json-enc">
    <div class="max-w-4xl mx-auto">
        <!-- En-tête du plugin -->
        <div class="bg-gray-800 rounded-lg p-6 mb-6">
            <div class="flex justify-between items-start mb-6">
                <div>
                    <h1 class="text-2xl font-bold text-blue-400">{{ plugin.name }}</h1>
                    <p class="text-gray-400">Version {{ plugin.version }}</p>
                </div>
                <div class="text-gray-400">
                    <p>Auteur: {{ plugin.author }}</p>
                </div>
            </div>
            
            <div class="mb-6">
                <p class="text-gray-400">{{ plugin.description }}</p>
            </div>

            <div class="flex flex-wrap gap-2">
                {% for category in plugin.categories %}
                    <span class="px-3 py-1 bg-gray-700 rounded-full text-sm text-gray-300">{{ category }}</span>
                {% endfor %}
            </div>
        </div>

        <!-- Association géocache -->
        <div class="bg-gray-800 rounded-lg p-6 mb-6" data-plugin-interface-target="geocacheAssociation">
            <h3 class="text-sm font-medium text-gray-300 mb-2">Association à une géocache</h3>
            <div class="flex flex-wrap gap-3 items-end">
                <!-- Sélection parmi les géocaches ouvertes -->
                <div class="flex-grow">
                    <label class="block text-xs text-gray-400 mb-1">Géocaches ouvertes</label>
                    <div class="flex">
                        <select class="flex-grow bg-gray-700 text-white rounded-l py-2 px-3 border border-gray-600"
                                data-plugin-interface-target="geocacheSelect"
                                data-skip-association="false"
                                onchange="selectGeocache(event, this.closest('[data-controller=\'plugin-interface\']'))">
                            <option value="">Sélectionner une géocache...</option>
                            <!-- Les options seront remplies par JavaScript -->
                        </select>
                        <button type="button"
                                class="bg-gray-600 hover:bg-gray-500 text-white px-3 py-2 rounded-r border-t border-r border-b border-gray-600"
                                onclick="loadOpenGeocaches(this.closest('[data-controller=\'plugin-interface\']'))"
                                title="Actualiser la liste des géocaches ouvertes">
                            <i class="fas fa-sync-alt"></i>
                        </button>
                    </div>
                </div>
                
                <!-- OU -->
                <div class="text-gray-500 px-2">OU</div>
                
                <!-- Saisie manuelle d'un GC code -->
                <div class="flex-grow">
                    <label class="block text-xs text-gray-400 mb-1">Code GC</label>
                    <div class="flex">
                        <input type="text" 
                               class="flex-grow bg-gray-700 text-white rounded-l py-2 px-3 border border-gray-600"
                               placeholder="GC12ABC" 
                               data-plugin-interface-target="gcCodeInput">
                        <button type="button"
                                class="bg-blue-600 hover:bg-blue-500 text-white px-4 py-2 rounded-r"
                                onclick="associateGcCode(event, this.closest('[data-controller=\'plugin-interface\']'))"
                                >
                            Associer
                        </button>
                    </div>
                </div>
            </div>
            
            <!-- Informations sur la géocache associée -->
            <div class="mt-3 bg-gray-700 rounded p-3 hidden" data-plugin-interface-target="associatedGeocacheInfo">
                <div class="flex items-center justify-between">
                    <div>
                        <span class="text-xs text-gray-400">Géocache associée :</span>
                        <span class="text-white font-medium ml-1" data-plugin-interface-target="associatedGeocacheName"></span>
                        <span class="text-gray-400 ml-2" data-plugin-interface-target="associatedGeocacheCode"></span>
                    </div>
                    <div class="flex items-center gap-3">
                        <button type="button"
                                class="text-xs text-blue-400 hover:text-blue-300 flex items-center"
                                onclick="openGeocacheDetails(this.closest('[data-controller=\'plugin-interface\']'))">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-3 w-3 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14" />
                            </svg>
                            Ouvrir Géocache
                        </button>
                        <button type="button"
                                class="text-xs text-red-400 hover:text-red-300"
                                onclick="removeGeocacheAssociation(this.closest('[data-controller=\'plugin-interface\']'))">
                            Supprimer l'association
                        </button>
                    </div>
                </div>
                <div class="mt-2 text-xs text-white" data-plugin-interface-target="originalCoordinates">
                    <span class="text-gray-400">Coordonnées d'origine : </span>
                    <span data-plugin-interface-target="originalCoordinatesValue">Chargement...</span>
                </div>
            </div>
        </div>

        <!-- Formulaire des inputs -->
        {% if not plugin.params.get('geocacheId') %}
        <form class="bg-gray-800 rounded-lg p-6 mb-6"
              data-plugin-interface-target="form">
            
            {% for input_name, input_config in plugin.input_types.items() %}
                {% if input_name == 'mode' and 'solver' in plugin.categories %}
                    <!-- Mode caché mais toujours présent avec valeur "decode" pour les plugins Solver -->
                    <input type="hidden" id="{{ input_name }}" name="{{ input_name }}" value="decode">
                {% elif (input_name == 'text' or input_name == 'input_text') and 'solver' in plugin.categories %}
                    <!-- Texte à traiter caché mais présent pour les plugins Solver -->
                    <input type="hidden" id="{{ input_name }}" name="{{ input_name }}" data-geocache-solver-target="pluginInputText">
                {% else %}
                    <div class="mb-4">
                        <label for="{{ input_name }}" class="block text-sm font-medium text-gray-300 mb-2">
                            {{ input_config.label }}
                        </label>

                        {% if input_config.type == "string" %}
                            <input type="text" 
                                id="{{ input_name }}"
                                name="{{ input_name }}"
                                class="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-md text-gray-100 focus:outline-none focus:ring-2 focus:ring-blue-500"
                                placeholder="{{ input_config.placeholder|default('') }}"
                                value="{{ plugin.params.get(input_name, input_config.default|default('')) }}">
                        {% elif input_config.type == "float" or input_config.type == "number" %}
                            <input type="number" 
                                id="{{ input_name }}"
                                name="{{ input_name }}"
                                class="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-md text-gray-100 focus:outline-none focus:ring-2 focus:ring-blue-500"
                                placeholder="{{ input_config.placeholder|default('') }}"
                                value="{{ plugin.params.get(input_name, input_config.default|default('0')) }}"
                                step="{{ input_config.step|default('any') }}"
                                min="{{ input_config.min|default('') }}"
                                max="{{ input_config.max|default('') }}">
                        {% elif input_config.type == "select" %}
                            <select id="{{ input_name }}"
                                    name="{{ input_name }}"
                                    class="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-md text-gray-100 focus:outline-none focus:ring-2 focus:ring-blue-500">
                                {% for option in input_config.options %}
                                    <option value="{{ option }}" 
                                            {% if option == input_config.default %}selected{% endif %}>
                                        {{ option }}
                                    </option>
                                {% endfor %}
                            </select>
                        {% elif input_config.type == "checkbox" or input_config.type == "boolean" %}
                            <div class="flex items-center">
                                <input type="checkbox" 
                                        id="{{ input_name }}"
                                        name="{{ input_name }}"
                                        class="h-4 w-4 rounded border-gray-600 text-blue-600 focus:ring-blue-500"
                                        {% if input_config.default %}checked{% endif %}>
                                <span class="ml-2 text-sm text-gray-300">{{ input_config.description|default('') }}</span>
                            </div>
                        {% endif %}
                    </div>
                {% endif %}
            {% endfor %}

            <!-- Option brute-force si disponible -->
            {% if plugin.brute_force %}
                <div class="mb-4 mt-6 border-t border-gray-700 pt-4">
                    <div class="flex items-center">
                        <input type="checkbox" 
                                id="brute_force"
                                name="brute_force"
                                class="h-4 w-4 rounded border-gray-600 text-blue-600 focus:ring-blue-500">
                        <label for="brute_force" class="ml-2 text-sm font-medium text-gray-300">
                            Utiliser le mode force brute
                        </label>
                    </div>
                </div>
            {% endif %}

            <!-- Option enable-scoring si disponible -->
            {% if plugin.enable_scoring %}
                <div class="mb-4 mt-2">
                    <div class="flex items-center">
                        <input type="checkbox" 
                                id="enable_scoring"
                                name="enable_scoring"
                                class="h-4 w-4 rounded border-gray-600 text-blue-600 focus:ring-blue-500"
                                checked>
                        <label for="enable_scoring" class="ml-2 text-sm font-medium text-gray-300">
                            Activer le scoring automatique
                        </label>
                    </div>
                </div>
            {% endif %}

            <div class="mt-6 flex justify-end space-x-4">
                <button type="button" 
                        data-action="click->geocache-solver#cancelPlugin"
                        class="px-4 py-2 bg-gray-600 text-white rounded hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-gray-500">
                    Annuler
                </button>
                {% if 'solver' in plugin.categories %}
                    <button type="button" 
                            data-action="click->geocache-solver#executePlugin"
                            data-plugin-id="{{ plugin.id }}"
                            data-plugin-name="{{ plugin.name }}"
                            class="px-4 py-2 bg-purple-600 text-white rounded hover:bg-purple-700 focus:outline-none focus:ring-2 focus:ring-purple-500">
                        Exécuter
                    </button>
                {% else %}
                    <button type="button" 
                            data-action="plugin-interface#execute"
                            class="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 debug-button">
                        Exécuter
                    </button>
                {% endif %}
            </div>
        </form>
        {% endif %}

        <!-- Zone de résultat -->
        <div data-plugin-interface-target="output" 
             class="bg-gray-800 rounded-lg p-6 {% if not plugin.params.get('geocacheId') %}hidden{% endif %} {% if 'solver' in plugin.categories %}hidden{% endif %}">
            <!-- La zone sera remplie dynamiquement par le JavaScript -->
        </div>
        
        {% if 'solver' in plugin.categories %}
        <div class="plugin-result mt-4 hidden" data-geocache-solver-target="pluginResult">
            <div class="bg-gray-900 rounded-lg p-3 border border-gray-700">
                <div class="text-sm text-gray-300 whitespace-pre-wrap" data-geocache-solver-target="pluginResultText"></div>
            </div>
        </div>
        {% endif %}
    </div>
</div>

<script>
    // Script optimisé pour exécuter les plugins dans GoldenLayout
    (function() {
        // Permettre au DOM de se charger complètement
        setTimeout(function() {
            // Trouver tous les éléments racine de plugin dans la page
            const allPluginRoots = document.querySelectorAll('[data-controller="plugin-interface"]');
            if (!allPluginRoots || allPluginRoots.length === 0) return;
            
            // Identifier notre élément (le dernier ajouté au DOM)
            const rootElement = allPluginRoots[allPluginRoots.length - 1];
            
            // Récupérer le nom du plugin
            const pluginName = rootElement.dataset.pluginName || 
                               rootElement.querySelector('h1.text-2xl.font-bold.text-blue-400')?.textContent.trim() || 
                               'inconnu';
            
            // Identifiant unique pour le débogage
            const uniqueId = 'p-' + Date.now().toString().slice(-4) + '-' + Math.floor(Math.random() * 1000);
            rootElement.dataset.debugId = uniqueId;
            
            console.log(`Plugin [${pluginName}] chargé (${uniqueId})`);

            // === NOUVELLE LIGNE POUR SUPPRIMER L'ASSOCIATION AU DÉMARRAGE ===
            if (pluginName && pluginName !== 'inconnu') {
                const storageKey = `plugin_${pluginName}_geocache`;
                sessionStorage.removeItem(storageKey);
                console.log(`[Inline Script] Association de géocache supprimée pour ${pluginName} (initialisation)`);
            }
            // =================================================================
            
            // S'assurer que le sélecteur de géocaches a l'attribut pour éviter l'association automatique
            const geocacheSelect = rootElement.querySelector('[data-plugin-interface-target="geocacheSelect"]');
            if (geocacheSelect) {
                geocacheSelect.dataset.skipAssociation = "true";
            }
            
            // Désactiver complètement l'association automatique lors de l'initialisation
            rootElement.dataset.disableAutoAssociation = "true";
            
            // Initialiser les fonctionnalités d'association de géocache avec le flag pour éviter l'association automatique
            initGeocacheAssociationFeatures(rootElement, true);
            
            // Remplacer les attributs onclick et onchange par des gestionnaires d'événements JavaScript
            setupEventHandlers(rootElement);
            
            // Une fois l'initialisation terminée, réactiver la possibilité d'association manuelle
            setTimeout(() => {
                rootElement.dataset.disableAutoAssociation = "false";
            }, 2000);
            
            // Chercher le bouton d'exécution
            const executeButton = rootElement.querySelector('.debug-button');
            if (!executeButton) return;
            
            // Ajouter un gestionnaire d'événement directement
            executeButton.addEventListener('click', function(event) {
                event.preventDefault(); // Empêcher toute action par défaut
                
                // Tenter d'utiliser le contrôleur Stimulus si disponible
                if (window.StimulusApp && window.StimulusApp.controllers) {
                    const controller = window.StimulusApp.controllers.find(
                        c => c.context.identifier === 'plugin-interface' && c.element === rootElement
                    );
                    
                    if (controller) {
                        console.log(`Utilisation du contrôleur Stimulus pour [${pluginName}]`);
                        controller.execute(event);
                        return;
                    }
                }
                
                // Si pas de contrôleur Stimulus, utiliser l'appel API direct
                console.log(`Exécution directe pour [${pluginName}]`);
                
                // Préparer l'affichage
                const output = rootElement.querySelector('[data-plugin-interface-target="output"]');
                if (output) {
                    output.classList.remove('hidden');
                    output.innerHTML = '<div class="flex items-center justify-center p-4"><div class="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-500"></div></div>';
                }
                
                // Récupérer les données du formulaire
                let data = {};
                const form = rootElement.querySelector('[data-plugin-interface-target="form"]');
                if (form) {
                    // Collecter tous les champs
                    const formData = new FormData(form);
                    for (let [key, value] of formData.entries()) {
                        data[key] = value;
                    }
                    
                    // Traitement spécial pour certains champs
                    const modeSelect = form.querySelector('#mode');
                    if (modeSelect) data.mode = modeSelect.value;
                    
                    const bruteForceCheckbox = form.querySelector('#brute_force');
                    if (bruteForceCheckbox) data.brute_force = bruteForceCheckbox.checked;
                    
                    const enableScoringCheckbox = form.querySelector('#enable_scoring');
                    if (enableScoringCheckbox) data.enable_scoring = enableScoringCheckbox.checked;
                } else {
                    // Si pas de formulaire, utiliser l'ID géocache
                    const geocacheId = rootElement.dataset.pluginInterfaceIdValue;
                    if (geocacheId && geocacheId !== 'default') {
                        data.geocache_id = geocacheId;
                    }
                }
                
                // Appel API
                fetch(`/api/plugins/${pluginName}/execute`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Accept': 'application/json'
                    },
                    body: JSON.stringify(data)
                })
                .then(response => {
                    if (!response.ok) throw new Error('Erreur réseau');
                    
                    // Déterminer le type de contenu
                    const contentType = response.headers.get('content-type');
                    if (contentType && contentType.includes('application/json')) {
                        return response.json().then(data => ({
                            isJson: true,
                            content: data
                        }));
                    } else {
                        return response.text().then(text => ({
                            isJson: false,
                            content: text
                        }));
                    }
                })
                .then(result => {
                    if (!output) return;
                    
                    // Traiter les résultats HTML (ancien format)
                    if (!result.isJson) {
                        output.innerHTML = result.content;
                        return;
                    }
                    
                    // Traiter les résultats JSON
                    const data = result.content;
                    let normalizedData = { ...data };
                    
                    // Vérifier la présence de coordonnées GPS dans les résultats
                    let coordinatesFound = false;
                    
                    // Pour le nouveau format standardisé
                    if (data.results && Array.isArray(data.results) && data.results.length > 0) {
                        // Chercher des coordonnées dans le meilleur résultat ou le premier résultat
                        const bestResult = data.summary && data.summary.best_result_id ?
                            data.results.find(r => r.id === data.summary.best_result_id) :
                            data.results[0];
                            
                            // Chercher les coordonnées à plusieurs emplacements possibles dans la structure
                            let coordinates = null;
                            
                            if (bestResult.coordinates && bestResult.coordinates.exist) {
                                coordinates = bestResult.coordinates;
                            } else if (bestResult.scoring && bestResult.scoring.coordinates && bestResult.scoring.coordinates.exist) {
                                coordinates = bestResult.scoring.coordinates;
                            }
                            
                            if (coordinates) {
                                // Émettre un événement avec les coordonnées détectées
                                console.log('Coordonnées GPS trouvées:', coordinates);
                                
                                // Envoyer également l'événement pour le contrôleur (au cas où il fonctionne)
                                const event = new CustomEvent('coordinatesDetected', {
                                    detail: coordinates,
                                    bubbles: true
                                });
                                document.dispatchEvent(event);
                                coordinatesFound = true;
                            }
                    } 
                    // Pour l'ancien format
                    else if (data.coordinates && data.coordinates.exist) {
                        // Émettre un événement avec les coordonnées détectées
                        console.log('Coordonnées GPS trouvées (ancien format):', data.coordinates);
                        
                        const event = new CustomEvent('coordinatesDetected', {
                            detail: data.coordinates,
                            bubbles: true
                        });
                        document.dispatchEvent(event);
                        coordinatesFound = true;
                        
                        // Rendre visible la section des coordonnées
                        const coordSection = rootElement.querySelector('[data-plugin-interface-target="coordinatesSection"]');
                        if (coordSection) coordSection.classList.remove('hidden');
                    }
                    // Vérifier également dans data.scoring
                    else if (data.scoring && data.scoring.coordinates && data.scoring.coordinates.exist) {
                        console.log('Coordonnées GPS trouvées (format scoring):', data.scoring.coordinates);
                        
                        const event = new CustomEvent('coordinatesDetected', {
                            detail: data.scoring.coordinates,
                            bubbles: true
                        });
                        document.dispatchEvent(event);
                        coordinatesFound = true;
                        
                        // Rendre visible la section des coordonnées
                        const coordSection = rootElement.querySelector('[data-plugin-interface-target="coordinatesSection"]');
                        if (coordSection) coordSection.classList.remove('hidden');
                    }
                    
                    // Si aucune coordonnée n'est trouvée, émettre un événement avec exist=false
                    if (!coordinatesFound) {
                        const event = new CustomEvent('coordinatesDetected', {
                            detail: { exist: false },
                            bubbles: true
                        });
                        document.dispatchEvent(event);
                    }

                    // Gérer le nouveau format standardisé
                    if (data.results && Array.isArray(data.results)) {
                        // Nouveau format
                        let resultsHtml = '';
                        
                        // Afficher d'abord le résumé s'il existe
                        if (data.summary) {
                            resultsHtml += `
                            <div class="bg-gray-700 rounded-lg p-4 mb-4">
                                <h3 class="text-lg font-medium text-blue-400 mb-2">Résumé</h3>
                                <div class="bg-gray-800 p-4 rounded">
                                    <p class="text-gray-300">${data.summary.message || `${data.summary.total_results} résultat(s)`}</p>
                                    ${data.status === 'error' ? `<p class="text-red-400 mt-2">Erreur: ${data.summary.message || 'Une erreur est survenue'}</p>` : ''}
                                    ${data.plugin_info ? `<p class="text-gray-400 text-sm mt-2">Temps d'exécution: ${data.plugin_info.execution_time || 0} ms</p>` : ''}
                                </div>
                            </div>`;
                        }
                        
                        // Afficher chaque résultat
                        data.results.forEach((result, index) => {
                            const isBest = data.summary && data.summary.best_result_id === result.id;
                            
                            resultsHtml += `
                            <div class="bg-gray-700 rounded-lg p-4 mb-4 ${isBest ? 'border-2 border-blue-500' : ''}">
                                <div class="flex justify-between items-start mb-2">
                                    <h3 class="text-lg font-medium ${isBest ? 'text-blue-400' : 'text-gray-300'}">
                                        Résultat ${index + 1} ${isBest ? '(Meilleur résultat)' : ''}
                                    </h3>
                                    <div class="bg-gray-900 px-2 py-1 rounded text-sm">
                                        Confiance: <span class="font-bold ${getConfidenceColor(result.confidence)}">${Math.round(result.confidence * 100)}%</span>
                                    </div>
                                </div>
                                
                                <div class="bg-gray-800 p-4 rounded mb-3">
                                    <textarea class="result-output w-full bg-gray-800 text-gray-300 border border-gray-700 focus:border-blue-500 p-2 rounded resize-y"
                                    data-index="${index}" data-result-id="${result.id}">${result.text_output || ''}</textarea>
                                </div>`;
                                
                            // Afficher les paramètres utilisés si présents
                            if (result.parameters && Object.keys(result.parameters).length > 0) {
                                resultsHtml += `
                                <div class="mt-2 p-2 bg-gray-800 rounded">
                                    <h4 class="text-sm font-medium text-gray-400 mb-1">Paramètres utilisés:</h4>
                                    <div class="text-xs text-gray-300 grid grid-cols-2 gap-1">
                                        ${Object.entries(result.parameters).map(([key, value]) => 
                                            `<div><span class="text-gray-500">${key}:</span> ${value}</div>`
                                        ).join('')}
                                    </div>
                                </div>`;
                            }
                            
                            // Récupérer les coordonnées à partir des différentes positions possibles
                            let coordinates = null;
                            
                            if (result.coordinates && result.coordinates.exist) {
                                coordinates = result.coordinates;
                            } else if (result.scoring && result.scoring.coordinates && result.scoring.coordinates.exist) {
                                coordinates = result.scoring.coordinates;
                            }
                            
                            if (coordinates) {
                                resultsHtml += `
                                <div class="mt-3 p-3 bg-gray-800 rounded">
                                    <div class="flex items-center justify-between mb-2">
                                        <h4 class="text-sm font-medium text-blue-400">Coordonnées GPS détectées</h4>
                                        <span class="px-3 py-1 text-xs rounded-full bg-green-600">Coordonnées trouvées</span>
                                    </div>
                                    <div class="grid grid-cols-1 gap-2">
                                        <div class="flex items-center">
                                            <span class="text-gray-400 text-sm w-20">Format DDM:</span>
                                            <span class="text-white font-medium">${coordinates.ddm || 'N/A'}</span>
                                        </div>
                                        <div class="grid grid-cols-2 gap-2">
                                            <div class="flex items-center">
                                                <span class="text-gray-400 text-sm w-20">Latitude:</span>
                                                <span class="text-white">${coordinates.ddm_lat || 'N/A'}</span>
                                            </div>
                                            <div class="flex items-center">
                                                <span class="text-gray-400 text-sm w-20">Longitude:</span>
                                                <span class="text-white">${coordinates.ddm_lon || 'N/A'}</span>
                                            </div>
                                        </div>
                                        <div class="mt-2 flex gap-2">
                                            <button type="button" 
                                                    class="text-xs bg-blue-700 hover:bg-blue-600 text-white px-3 py-1 rounded cursor-pointer copy-coords" 
                                                    data-coords="${coordinates.ddm || ''}">
                                                Copier
                                            </button>
                                            <button type="button" 
                                                    class="text-xs bg-indigo-700 hover:bg-indigo-600 text-white px-3 py-1 rounded cursor-pointer add-waypoint"
                                                    data-ddm="${coordinates.ddm || ''}" 
                                                    data-lat="${coordinates.ddm_lat || ''}" 
                                                    data-lon="${coordinates.ddm_lon || ''}">
                                                Ajouter WP
                                            </button>
                                            <button type="button" 
                                                    class="text-xs bg-purple-700 hover:bg-purple-600 text-white px-3 py-1 rounded cursor-pointer create-waypoint"
                                                    data-ddm="${coordinates.ddm || ''}" 
                                                    data-lat="${coordinates.ddm_lat || ''}" 
                                                    data-lon="${coordinates.ddm_lon || ''}">
                                                Créer waypoint
                                            </button>
                                        </div>
                                    </div>
                                </div>`;
                            }
                            
                            resultsHtml += `</div>`;
                        });
                        
                        // Ajouter l'option pour afficher le JSON brut
                        resultsHtml += `
                        <div class="mt-4">
                            <button class="text-sm text-blue-400 hover:text-blue-300" id="toggle-raw-${uniqueId}">
                                Afficher le format brut
                            </button>
                            <div class="raw-output hidden mt-2 bg-gray-700 rounded-lg p-4">
                                <textarea class="w-full h-60 bg-gray-800 text-gray-300 border border-gray-700 focus:border-blue-500 p-2 rounded resize-y">${JSON.stringify(data, null, 2)}</textarea>
                            </div>
                        </div>`;
                        
                        // Mettre à jour le DOM avec le HTML généré
                        output.innerHTML = resultsHtml;
                        
                        // Configurer les boutons de coordination
                        setupCoordinateButtons();
                        
                        // Ajouter l'événement pour afficher/masquer le format brut
                        const toggleButton = output.querySelector(`#toggle-raw-${uniqueId}`);
                        const rawOutput = output.querySelector('.raw-output');
                        
                        if (toggleButton && rawOutput) {
                            toggleButton.addEventListener('click', function() {
                                rawOutput.classList.toggle('hidden');
                                toggleButton.textContent = rawOutput.classList.contains('hidden') 
                                    ? 'Afficher le format brut'
                                    : 'Masquer le format brut';
                            });
                        }
                    }
                    // Gérer l'ancien format pour rétrocompatibilité
                    else {
                        // Normaliser la structure
                        if (data.result && data.result.text && data.result.text.text_output !== undefined) {
                            normalizedData.text_output = data.result.text.text_output;
                        } else if (data.output !== undefined) {
                            normalizedData.text_output = data.output;
                        }
                        
                        // Extraire le log
                        if (data.result && data.result.log !== undefined) {
                            normalizedData.log = data.result.log;
                        } else if (data.original_result && data.original_result.result && data.original_result.result.log) {
                            normalizedData.log = data.original_result.result.log;
                        }
                        
                        // Afficher les résultats (ancien format)
                        output.innerHTML = `
                            <div class="space-y-4">
                                <div class="bg-gray-700 rounded-lg p-4">
                                    <h3 class="text-lg font-medium text-gray-300 mb-2">Résultat</h3>
                                    <div class="bg-gray-800 p-4 rounded">
                                        <textarea class="w-full bg-gray-800 text-gray-300 border border-gray-700 focus:border-blue-500 p-2 rounded resize-y">${normalizedData.text_output || ''}</textarea>
                                    </div>
                                </div>
                                ${normalizedData.log ? `
                                <div class="bg-gray-700 rounded-lg p-4">
                                    <h3 class="text-lg font-medium text-gray-300 mb-2">Détails de la projection</h3>
                                    <div class="bg-gray-800 p-4 rounded">
                                        <pre class="w-full bg-gray-800 text-gray-300 font-mono text-sm whitespace-pre-wrap">${normalizedData.log}</pre>
                                    </div>
                                </div>
                                ` : ''}
                                
                                <!-- Affichage des coordonnées GPS si elles existent -->
                                ${normalizedData.coordinates ? `
                                <div class="bg-gray-700 rounded-lg p-4">
                                    <h3 class="text-lg font-medium text-gray-300 mb-2">Coordonnées détectées</h3>
                                    
                                    <div class="mb-3">
                                        <label class="inline-flex items-center">
                                            <input type="checkbox" class="coords-exist-checkbox form-checkbox h-5 w-5 text-blue-600" 
                                                   ${normalizedData.coordinates.exist === true ? 'checked' : ''}
                                                   id="coords-exist-${uniqueId}">
                                            <span class="ml-2 text-gray-300">Coordonnées présentes</span>
                                        </label>
                                    </div>
                                    
                                    <div class="bg-gray-800 p-4 rounded grid grid-cols-1 gap-4 ${normalizedData.coordinates.exist === true ? '' : 'opacity-50'} coords-container-${uniqueId}">
                                        <div>
                                            <label for="coords-ddm-${uniqueId}" class="block text-sm font-medium text-gray-400 mb-1">Format DDM:</label>
                                            <input type="text" id="coords-ddm-${uniqueId}" class="w-full bg-gray-800 text-gray-300 border border-gray-700 focus:border-blue-500 p-2 rounded"
                                                   value="${normalizedData.coordinates.ddm || ''}" ${normalizedData.coordinates.exist === true ? '' : 'disabled'}>
                                        </div>
                                        
                                        <div class="grid grid-cols-2 gap-4">
                                            <div>
                                                <label for="coords-lat-${uniqueId}" class="block text-sm font-medium text-gray-400 mb-1">Latitude:</label>
                                                <input type="text" id="coords-lat-${uniqueId}" class="w-full bg-gray-800 text-gray-300 border border-gray-700 focus:border-blue-500 p-2 rounded"
                                                       value="${normalizedData.coordinates.ddm_lat || ''}" ${normalizedData.coordinates.exist === true ? '' : 'disabled'}>
                                            </div>
                                            <div>
                                                <label for="coords-lon-${uniqueId}" class="block text-sm font-medium text-gray-400 mb-1">Longitude:</label>
                                                <input type="text" id="coords-lon-${uniqueId}" class="w-full bg-gray-800 text-gray-300 border border-gray-700 focus:border-blue-500 p-2 rounded"
                                                       value="${normalizedData.coordinates.ddm_lon || ''}" ${normalizedData.coordinates.exist === true ? '' : 'disabled'}>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                                ` : ''}
                                
                                <!-- Ajout de l'affichage du format brut -->
                                <div class="mt-4">
                                    <button class="text-sm text-blue-400 hover:text-blue-300" id="toggle-raw-${uniqueId}">
                                        Afficher le format brut
                                    </button>
                                    <div class="raw-output hidden mt-2 bg-gray-700 rounded-lg p-4">
                                        <textarea class="w-full h-40 bg-gray-800 text-gray-300 border border-gray-700 focus:border-blue-500 p-2 rounded resize-y">${JSON.stringify(normalizedData, null, 2)}</textarea>
                                    </div>
                                </div>
                            </div>
                        `;
                        
                        // Configurer les boutons de coordination après l'affichage des résultats
                        setupCoordinateButtons();
                        
                        // Ajouter les événements pour la gestion des coordonnées
                        const coordsExistCheckbox = output.querySelector(`#coords-exist-${uniqueId}`);
                        const coordsContainer = output.querySelector(`.coords-container-${uniqueId}`);
                        
                        if (coordsExistCheckbox && coordsContainer) {
                            coordsExistCheckbox.addEventListener('change', function() {
                                const exists = this.checked;
                                coordsContainer.classList.toggle('opacity-50', !exists);
                                
                                // Activer/désactiver les champs de saisie
                                const inputs = coordsContainer.querySelectorAll('input[type="text"]');
                                inputs.forEach(input => {
                                    input.disabled = !exists;
                                });
                                
                                // Mettre à jour la valeur dans les données normalisées
                                if (normalizedData.coordinates) {
                                    normalizedData.coordinates.exist = exists;
                                    
                                    // Mettre à jour le textarea du format brut si visible
                                    const rawTextarea = output.querySelector('.raw-output textarea');
                                    if (rawTextarea && !output.querySelector('.raw-output').classList.contains('hidden')) {
                                        rawTextarea.value = JSON.stringify(normalizedData, null, 2);
                                    }
                                }
                            });
                        }
                    }
                })
                .catch(error => {
                    if (output) {
                        output.innerHTML = `<div class="bg-red-900 text-red-100 p-4 rounded-lg">Erreur: ${error.message}</div>`;
                    }
                });
            });
            
            // Écouter les événements de changements dans GoldenLayout pour rafraîchir les géocaches ouvertes
            if (window.parent && window.parent.postMessage) {
                // Créer un écouteur d'événements personnalisé pour les changements de layout
                window.addEventListener('message', function(event) {
                    // Vérifier si c'est un événement de changement de layout (tab ouvert, fermé, etc.)
                    if (event.data && 
                        (event.data.type === 'componentCreated' || 
                         event.data.type === 'tabActivated' || 
                         event.data.type === 'geocacheDetailsOpened')) {
                        
                        console.log("Événement de layout détecté, rafraîchissement des géocaches ouvertes");
                        // Rafraîchir la liste des géocaches ouvertes
                        setTimeout(() => {
                            loadOpenGeocaches(rootElement);
                        }, 500); // Délai pour s'assurer que les composants sont bien initialisés
                    }
                });
            }
        }, 100);
    })();
    
    // Fonction utilitaire pour obtenir la couleur selon le niveau de confiance
    function getConfidenceColor(confidence) {
        if (confidence >= 0.8) return 'text-green-400';
        if (confidence >= 0.5) return 'text-yellow-400';
        if (confidence >= 0.3) return 'text-orange-400';
        return 'text-red-400';
    }
    
    // Gestion des événements pour les boutons de coordonnées après le chargement des résultats
    function setupCoordinateButtons() {
        // Gestion des boutons de copie de coordonnées
        document.querySelectorAll('.copy-coords').forEach(button => {
            if (button.dataset.eventSetup) return; // Éviter la duplication des événements
            
            button.dataset.eventSetup = "true";
            button.addEventListener('click', function() {
                const coords = this.dataset.coords;
                if (coords) {
                    navigator.clipboard.writeText(coords).then(() => {
                        // Feedback visuel temporaire
                        const originalText = this.textContent;
                        this.innerHTML = '✓ Copié!';
                        this.classList.add('bg-green-600');
                        this.classList.remove('bg-blue-700', 'hover:bg-blue-600');
                        
                        setTimeout(() => {
                            this.textContent = originalText;
                            this.classList.remove('bg-green-600');
                            this.classList.add('bg-blue-700', 'hover:bg-blue-600');
                        }, 1500);
                    });
                }
            });
        });
        
        // Gestion des boutons d'ajout de waypoint
        document.querySelectorAll('.add-waypoint').forEach(button => {
            if (button.dataset.eventSetup) return; // Éviter la duplication des événements
            
            button.dataset.eventSetup = "true";
            button.addEventListener('click', function(event) {
                // Appeler explicitement la fonction addAsWaypoint
                const element = this.closest('[data-controller="plugin-interface"]');
                if (element) {
                    addAsWaypoint(event, element);
                } else {
                    console.error("Impossible de trouver l'élément parent avec data-controller='plugin-interface'");
                }
                
                // Feedback visuel
                const originalText = this.textContent;
                this.innerHTML = '✓ En cours...';
                this.classList.add('bg-indigo-800');
                this.classList.remove('bg-indigo-700', 'hover:bg-indigo-600');
                
                setTimeout(() => {
                    this.textContent = originalText;
                    this.classList.remove('bg-indigo-800');
                    this.classList.add('bg-indigo-700', 'hover:bg-indigo-600');
                }, 1500);
            });
        });
        
        // Gestion des boutons de création de waypoint
        document.querySelectorAll('.create-waypoint').forEach(button => {
            if (button.dataset.eventSetup) return; // Éviter la duplication des événements
            
            button.dataset.eventSetup = "true";
            button.addEventListener('click', function() {
                const coords = {
                    ddm: this.dataset.ddm,
                    ddm_lat: this.dataset.lat,
                    ddm_lon: this.dataset.lon
                };
                
                // Déclencher un événement personnalisé pour la création du waypoint
                const event = new CustomEvent('createWaypointFromCoordinates', {
                    detail: coords,
                    bubbles: true
                });
                this.dispatchEvent(event);
                
                // Feedback visuel temporaire
                const originalText = this.textContent;
                this.innerHTML = '✓ Demandé!';
                this.classList.add('bg-green-600');
                this.classList.remove('bg-purple-700', 'hover:bg-purple-600');
                
                setTimeout(() => {
                    this.textContent = originalText;
                    this.classList.remove('bg-green-600');
                    this.classList.add('bg-purple-700', 'hover:bg-purple-600');
                }, 1500);
                
                // Montrer une notification
                showNotification('Création de waypoint demandée', 'bg-blue-600');
            });
        });
    }
    
    // Fonction pour afficher une notification temporaire
    function showNotification(message, bgClass = 'bg-blue-600') {
        // Créer l'élément de notification s'il n'existe pas déjà
        let notif = document.querySelector('.coordinates-notification');
        if (!notif) {
            notif = document.createElement('div');
            notif.className = `coordinates-notification fixed bottom-5 right-5 p-3 rounded-lg text-white shadow-lg transition-opacity duration-300 ${bgClass}`;
            document.body.appendChild(notif);
        }
        
        // Définir le contenu et afficher
        notif.textContent = message;
        notif.style.opacity = '1';
        
        // Cacher après 3 secondes
        setTimeout(() => {
            notif.style.opacity = '0';
            setTimeout(() => {
                if (notif.parentNode) {
                    notif.parentNode.removeChild(notif);
                }
            }, 300);
        }, 3000);
    }
    
    // Fonction pour configurer tous les gestionnaires d'événements au lieu d'utiliser des attributs onclick/onchange
    function setupEventHandlers(rootElement) {
        console.log("Configuration des gestionnaires d'événements pour", rootElement);
        
        // Sélecteur de géocache
        const geocacheSelect = rootElement.querySelector('[data-plugin-interface-target="geocacheSelect"]');
        if (geocacheSelect) {
            geocacheSelect.removeAttribute('onchange');
            geocacheSelect.addEventListener('change', function(event) {
                selectGeocache(event, rootElement);
            });
        }
        
        // Bouton de rafraîchissement des géocaches ouvertes
        const refreshButton = rootElement.querySelector('[title="Actualiser la liste des géocaches ouvertes"]');
        if (refreshButton) {
            refreshButton.removeAttribute('onclick');
            refreshButton.addEventListener('click', function() {
                loadOpenGeocaches(rootElement);
            });
        }
        
        // Bouton d'association du code GC
        const associateButton = rootElement.querySelector('[data-plugin-interface-target="gcCodeInput"]')?.nextElementSibling;
        if (associateButton) {
            associateButton.removeAttribute('onclick');
            associateButton.addEventListener('click', function(event) {
                associateGcCode(event, rootElement);
            });
        }
        
        // Bouton d'ouverture des détails de la géocache
        const openDetailsButton = rootElement.querySelector('[data-plugin-interface-target="associatedGeocacheInfo"] button.text-blue-400');
        if (openDetailsButton) {
            openDetailsButton.removeAttribute('onclick');
            openDetailsButton.addEventListener('click', function() {
                openGeocacheDetails(rootElement);
            });
        }
        
        // Bouton de suppression de l'association
        const removeAssociationButton = rootElement.querySelector('[data-plugin-interface-target="associatedGeocacheInfo"] button.text-red-400');
        if (removeAssociationButton) {
            removeAssociationButton.removeAttribute('onclick');
            removeAssociationButton.addEventListener('click', function() {
                removeGeocacheAssociation(rootElement);
            });
        }
    }
</script>

<!-- Fonctions pour les actions d'association de geocache -->
<script>
    // Fonctions pour interagir directement avec les éléments
    // Compteur pour les logs
    let pluginInterfaceCount = 0;
    
    function loadOpenGeocaches(element) {
        console.log("Chargement des géocaches ouvertes depuis le bouton");
        const geocacheSelect = element.querySelector('[data-plugin-interface-target="geocacheSelect"]');
        
        if (geocacheSelect) {
            // Définir le flag pour ignorer l'association automatique lors du chargement
            geocacheSelect.dataset.skipAssociation = "true";
            
            // Réinitialiser d'abord le select pour éviter des associations indésirables
            geocacheSelect.value = '';
            
            // Initialiser le sélecteur avec les géocaches ouvertes
            initGeocacheSelector(element, geocacheSelect, true);
        }
    }
    
    function selectGeocache(event, element) {
        const select = event.target;

        if (select.dataset.skipAssociation === "true") {
            console.log("Le flag skipAssociation était 'true'. L\'association va maintenant avoir lieu et le flag est réinitialisé.");
            select.dataset.skipAssociation = "false";
            // PAS DE 'return;' ICI, ON CONTINUE
        }

        console.log("Sélection manuelle de géocache détectée");

        const selectedOption = select.options[select.selectedIndex];
        const selectedId = select.value;

        if (!selectedId || !selectedOption) {
            console.warn("Aucune géocache valide sélectionnée");
            return;
        }

        const geocacheName = selectedOption.dataset.name;
        const gcCode = selectedOption.dataset.gcCode;
        const databaseId = selectedOption.dataset.databaseId;

        console.log(`Géocache sélectionnée: ${selectedId}`);
        console.log("Données de la géocache:", {
            name: geocacheName,
            code: gcCode,
            databaseId
        });

        if (!gcCode) {
            console.error("Code GC manquant pour la géocache sélectionnée");
            showErrorMessage(element, "Cette géocache n'a pas de code GC valide");
            return;
        }

        associateGeocache(element, {
            id: selectedId,
            name: geocacheName,
            code: gcCode,
            databaseId: databaseId || null
        });
    }
    
    function associateGcCode(event, element) {
        event.preventDefault();
        
        const gcCodeInput = element.querySelector('[data-plugin-interface-target="gcCodeInput"]');
        if (!gcCodeInput) {
            console.error("Champ de saisie de code GC introuvable");
            return;
        }
        
        const gcCode = gcCodeInput.value.trim().toUpperCase();
        if (!gcCode) {
            showErrorMessage(element, "Veuillez saisir un code GC");
            return;
        }
        
        console.log(`Tentative d'association avec le code GC: ${gcCode}`);
        
        // Rechercher parmi les géocaches ouvertes
        try {
            if (window.layoutStateManager) {
                const openGeocaches = window.layoutStateManager.getComponentsByType('geocache-details');
                console.log("Recherche parmi les géocaches ouvertes:", openGeocaches);
                
                // Chercher le code GC dans les métadonnées des géocaches
                const existingGeocache = openGeocaches.find(gc => 
                    gc.metadata && (
                        (gc.metadata.gcCode && gc.metadata.gcCode.toUpperCase() === gcCode) || 
                        (gc.metadata.code && gc.metadata.code.toUpperCase() === gcCode)
                    )
                );
                
                if (existingGeocache) {
                    console.log("Géocache trouvée parmi les onglets ouverts:", existingGeocache);
                    
                    // La géocache est déjà ouverte, on l'associe directement
                    associateGeocache(element, {
                        id: existingGeocache.id,
                        name: existingGeocache.metadata.name || "Sans nom",
                        code: gcCode, // Utiliser le code fourni pour garantir sa présence
                        databaseId: existingGeocache.metadata.databaseId || null
                    });
                } else {
                    console.log("Géocache non trouvée parmi les onglets ouverts, requête API nécessaire");
                    
                    // La géocache n'est pas ouverte, il faut faire une requête API
                    fetch(`/api/geocaches/by-code/${gcCode}`)
                        .then(response => {
                            if (!response.ok) {
                                throw new Error(`Géocache non trouvée: ${gcCode}`);
                            }
                            return response.json();
                        })
                        .then(data => {
                            console.log("Données de géocache récupérées:", data);
                            
                            associateGeocache(element, {
                                id: null, // Pas d'ID car non ouverte
                                name: data.name || gcCode,
                                code: gcCode, // Utiliser le code fourni
                                databaseId: data.id || null
                            });
                        })
                        .catch(error => {
                            console.error("Erreur lors de la récupération de la géocache:", error);
                            showErrorMessage(element, `Erreur: ${error.message}`);
                        });
                }
            } else {
                console.warn("layoutStateManager non disponible");
                showErrorMessage(element, "Impossible de vérifier les géocaches ouvertes");
            }
        } catch (error) {
            console.error("Erreur lors de l'association de la géocache:", error);
            showErrorMessage(element, `Erreur: ${error.message}`);
        }
        
        // Vider le champ de saisie
        gcCodeInput.value = '';
    }
    
    function openGeocacheDetails(element) {
        const geocache = loadGeocacheAssociation(element);
        if (!geocache || !geocache.code) {
            showErrorMessage(element, "Veuillez d'abord associer une géocache");
            return;
        }
        
        // Ouvrir l'onglet de la géocache
        window.parent.postMessage({ 
            type: 'openGeocacheDetails',
            geocacheId: geocache.databaseId,
            gcCode: geocache.code,
            name: geocache.name || geocache.code
        }, '*');
    }
    
    function removeGeocacheAssociation(element) {
        console.log("Suppression de l'association de géocache");
        
        const nameElement = element.querySelector('[data-plugin-interface-target="associatedGeocacheName"]');
        const codeElement = element.querySelector('[data-plugin-interface-target="associatedGeocacheCode"]');
        const infoElement = element.querySelector('[data-plugin-interface-target="associatedGeocacheInfo"]');
        const selectElement = element.querySelector('[data-plugin-interface-target="geocacheSelect"]');
        const coordsValueElement = element.querySelector('[data-plugin-interface-target="originalCoordinatesValue"]');
        
        // Masquer les infos
        if (infoElement) {
            infoElement.classList.add('hidden');
        }
        
        // Réinitialiser le sélecteur
        if (selectElement) {
            selectElement.value = "";
        }
        
        // Réinitialiser l'affichage des coordonnées
        if (coordsValueElement) {
            coordsValueElement.textContent = "";
        }
        
        // Supprimer du sessionStorage
        const pluginName = element.querySelector('h1.text-2xl.font-bold.text-blue-400')?.textContent.trim();
        if (pluginName) {
            sessionStorage.removeItem(`plugin_${pluginName}_geocache`);
        }
    }
    
    function addAsWaypoint(event, element) {
        console.log("=== Méthode addAsWaypoint appelée ===", event);
        
        // Récupération standard du geocache associé
        let geocache = loadGeocacheAssociation(element);
        
        // Méthode de secours #1: Vérifier la variable globale si elle existe
        if ((!geocache || !geocache.code) && window.lastAssociatedGeocache && window.lastAssociatedGeocache.code) {
            console.log("Utilisation de la variable globale lastAssociatedGeocache comme secours");
            geocache = window.lastAssociatedGeocache;
        }
        
        // Méthode de secours #2: Chercher parmi les onglets ouverts
        if (!geocache || !geocache.code) {
            console.log("Tentative de récupération d'une géocache parmi les onglets ouverts");
            
            if (window.layoutStateManager) {
                const openGeocaches = window.layoutStateManager.getComponentsByType('geocache-details');
                if (openGeocaches.length > 0) {
                    // Utiliser la première géocache ouverte comme secours
                    const firstGeocache = openGeocaches[0];
                    if (firstGeocache && firstGeocache.metadata) {
                        const gcCode = firstGeocache.metadata.gcCode || firstGeocache.metadata.code;
                        if (gcCode) {
                            console.log(`Utilisation de la première géocache ouverte comme secours: ${gcCode}`);
                            geocache = {
                                id: firstGeocache.id,
                                name: firstGeocache.metadata.name || "Sans nom",
                                code: gcCode,
                                databaseId: firstGeocache.metadata.databaseId || null
                            };
                        }
                    }
                }
            }
        }
        
        // Méthode de secours #3: Demander le code directement à l'utilisateur
        if (!geocache || !geocache.code) {
            const userCode = prompt("Aucune géocache associée. Veuillez entrer un code GC:", "GC");
            if (userCode && userCode.trim()) {
                geocache = {
                    code: userCode.trim().toUpperCase(),
                    name: "Géocache saisie manuellement"
                };
                // Sauvegarder cette association pour une utilisation ultérieure
                saveGeocacheAssociation(element, geocache);
            }
        }
        
        // Vérifier que nous avons maintenant un code GC
        if (!geocache || !geocache.code) {
            showErrorMessage(element, "Impossible d'associer une géocache. Veuillez d'abord associer une géocache.");
            return;
        }
        
        // Normaliser le code GC si nécessaire
        if (!geocache.code.startsWith('GC')) {
            geocache.code = `GC${geocache.code}`;
        }
        
        const button = event.currentTarget || event.target;
        const coordinates = {
            ddm: button.dataset.ddm,
            ddm_lat: button.dataset.lat,
            ddm_lon: button.dataset.lon
        };
        
        if (!coordinates.ddm) {
            showErrorMessage(element, "Coordonnées manquantes");
            return;
        }
        
        console.log(`Ajout de waypoint: ${coordinates.ddm} pour la géocache ${geocache.code}`);
        
        // Trouver le formulaire de waypoint
        let waypointForm = document.querySelector('[data-controller="waypoint-form"]');
        
        if (!waypointForm) {
            console.log("Panneau de détails de la géocache ou formulaire de waypoint non trouvé");
            
            // Ouvrir l'onglet de la géocache et préparer l'ajout d'un waypoint
            window.parent.postMessage({
                type: 'openGeocacheDetails',
                geocacheId: geocache.databaseId,
                gcCode: geocache.code,
                name: geocache.name || geocache.code
            }, '*');
            
            // Enregistrer cette géocache pour les utilisations futures
            window.lastAssociatedGeocache = geocache;
            
            showSuccessMessage(element, "L'onglet de la géocache est en cours d'ouverture. Veuillez réessayer d'ajouter le waypoint dans quelques secondes.");
            return;
        }
        
        // Préparer les éléments du formulaire
        const prefixInput = waypointForm.querySelector('[data-waypoint-form-target="prefixInput"]');
        const nameInput = waypointForm.querySelector('[data-waypoint-form-target="nameInput"]');
        const gcLatInput = waypointForm.querySelector('[data-waypoint-form-target="gcLatInput"]');
        const gcLonInput = waypointForm.querySelector('[data-waypoint-form-target="gcLonInput"]');
        const noteInput = waypointForm.querySelector('[data-waypoint-form-target="noteInput"]');
        const formToggleButton = waypointForm.querySelector('[data-action="click->waypoint-form#toggleForm"]');
        const form = waypointForm.querySelector('[data-waypoint-form-target="form"]');
        
        // Générer un nom de waypoint par défaut
        const pluginName = element.querySelector('h1.text-2xl.font-bold.text-blue-400')?.textContent.trim() || 'Plugin';
        let waypointName = `${pluginName}: Point détecté`;
        
        // Préparer les notes avec les informations disponibles
        let notes = `Point détecté par le plugin "${pluginName}".\nCoordonnées: ${coordinates.ddm}`;
        
        // Vérifier si le formulaire est actuellement caché et l'afficher si nécessaire
        if (form && form.classList.contains('hidden') && formToggleButton) {
            formToggleButton.click();
        }
        
        // Remplir le formulaire
        if (prefixInput) prefixInput.value = "PL"; // Pour Plugin
        if (nameInput) nameInput.value = waypointName;
        if (gcLatInput) gcLatInput.value = coordinates.ddm_lat;
        if (gcLonInput) gcLonInput.value = coordinates.ddm_lon;
        if (noteInput) noteInput.value = notes;
        
        // Faire défiler jusqu'au formulaire pour que l'utilisateur puisse le voir
        if (form) {
            form.scrollIntoView({behavior: 'smooth', block: 'center'});
        }
        
        // Enregistrer cette géocache pour les utilisations futures
        window.lastAssociatedGeocache = geocache;
        
        showSuccessMessage(element, "Formulaire de waypoint prérempli avec les coordonnées détectées");
    }
    
    function showErrorMessage(element, message, type = 'error') {
        // Créer un élément d'erreur s'il n'existe pas déjà
        let errorElement = document.getElementById('plugin-error-message');
        if (!errorElement) {
            errorElement = document.createElement('div');
            errorElement.id = 'plugin-error-message';
            errorElement.className = `bg-${type === "error" ? "red" : "green"}-600 text-white px-4 py-2 rounded-lg mb-4 flex items-center justify-between`;
            
            // Ajouter après la section d'association
            const associationSection = element.querySelector('[data-plugin-interface-target="geocacheAssociation"]');
            if (associationSection) {
                associationSection.parentNode.insertBefore(errorElement, associationSection.nextSibling);
            } else {
                // Fallback si la cible n'est pas disponible
                const form = element.querySelector('form');
                if (form) {
                    form.parentNode.insertBefore(errorElement, form);
                } else {
                    element.insertBefore(errorElement, element.firstChild);
                }
            }
        }
        
        // Mettre à jour le contenu
        errorElement.innerHTML = `
            <div class="flex items-center">
                <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"></path>
                </svg>
                <span>${message}</span>
            </div>
            <button class="text-white hover:text-gray-200" onclick="this.parentNode.remove()">
                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                </svg>
            </button>
        `;
        
        // Auto-supprimer après un délai
        setTimeout(() => {
            if (errorElement && errorElement.parentNode) {
                errorElement.remove();
            }
        }, 5000);
    }
    
    function showSuccessMessage(element, message) {
        showErrorMessage(element, message, 'success');
    }
</script>

<!-- Script d'initialisation des fonctionnalités d'association de géocache -->
<script>
    // Fonction principale pour initialiser les fonctionnalités d'association de géocache
    function initGeocacheAssociationFeatures(element, skipAutoAssociation = false) {
        console.log("Initialisation de l'élément plugin-interface #" + (++pluginInterfaceCount) + 
                    (skipAutoAssociation ? " (sans association auto)" : ""));
        
        // Trouver les éléments d'interface
        const gcCodeInput = element.querySelector('[data-plugin-interface-target="gcCodeInput"]');
        const geocacheSelect = element.querySelector('[data-plugin-interface-target="geocacheSelect"]');
        
        if (gcCodeInput && geocacheSelect) {
            console.log("Éléments d'interface trouvés, tentative d'initialisation directe");
            
            // S'assurer que le sélecteur a l'attribut skipAssociation correct
            geocacheSelect.dataset.skipAssociation = skipAutoAssociation ? "true" : "false";
            
            // Initialiser le sélecteur de géocache avec une tentative immédiate et des retentatives
            initGeocacheSelector(element, geocacheSelect, skipAutoAssociation);
            
            // Deuxième tentative de chargement des géocaches après un court délai
            // pour s'assurer que le layoutStateManager est complètement initialisé
            setTimeout(() => {
                initGeocacheSelector(element, geocacheSelect, skipAutoAssociation);
                
                // Troisième tentative après un délai plus long si nécessaire
                setTimeout(() => {
                    initGeocacheSelector(element, geocacheSelect, skipAutoAssociation);
                }, 1500);
            }, 500);
            
            // Charger une association existante si disponible (sans fallback si skipAutoAssociation est true)
            const savedGeocache = loadGeocacheAssociation(element, skipAutoAssociation);
            if (savedGeocache && savedGeocache.code) {
                console.log("Tentative de restauration d'une association sauvegardée");
                // Vérifier d'abord si la géocache est toujours ouverte
                if (savedGeocache.id && window.layoutStateManager) {
                    const openGeocaches = window.layoutStateManager.getComponentsByType('geocache-details');
                    const stillOpen = openGeocaches.some(gc => gc.id === savedGeocache.id);
                    
                    if (stillOpen) {
                        console.log("La géocache associée est toujours ouverte");
                        associateGeocache(element, savedGeocache);
                    } else if (savedGeocache.code) {
                        console.log("La géocache n'est plus ouverte, mais nous avons son code");
                        // La géocache n'est plus ouverte, mais nous avons son code
                        associateGeocache(element, savedGeocache);
                    }
                } else if (savedGeocache.code) {
                    // Pas d'ID, mais nous avons un code
                    console.log("Association avec code GC uniquement");
                    associateGeocache(element, savedGeocache);
                }
            } else if (!skipAutoAssociation) {
                console.log("Aucune association précédente trouvée ou association invalide");
                // Essayer de récupérer des informations à partir de l'URL
                const urlParams = new URLSearchParams(window.location.search);
                const gcId = urlParams.get('geocacheId');
                if (gcId && gcId !== 'default' && window.layoutStateManager) {
                    console.log("Tentative de récupération de la géocache à partir de l'ID dans l'URL:", gcId);
                    
                    const openGeocaches = window.layoutStateManager.getComponentsByType('geocache-details');
                    const matchingGeocache = openGeocaches.find(gc => 
                        gc.metadata && gc.metadata.databaseId === gcId
                    );
                    
                    if (matchingGeocache && matchingGeocache.metadata) {
                        const gcCode = matchingGeocache.metadata.gcCode || matchingGeocache.metadata.code;
                        if (gcCode) {
                            console.log(`Géocache trouvée via l'ID URL: ${gcCode}`);
                            associateGeocache(element, {
                                id: matchingGeocache.id,
                                name: matchingGeocache.metadata.name || "Sans nom",
                                code: gcCode,
                                databaseId: matchingGeocache.metadata.databaseId || null
                            });
                            return;
                        }
                    }
                }
                
                // Si aucune association n'est trouvée et qu'il y a des géocaches ouvertes,
                // suggérer visuellement la première (sans l'associer automatiquement)
                if (window.layoutStateManager) {
                    const openGeocaches = window.layoutStateManager.getComponentsByType('geocache-details');
                    if (openGeocaches.length > 0) {
                        const firstGeocache = openGeocaches[0];
                        if (firstGeocache && firstGeocache.metadata) {
                            const gcCode = firstGeocache.metadata.gcCode || firstGeocache.metadata.code;
                            if (gcCode) {
                                console.log(`Suggestion visuelle de la première géocache ouverte: ${gcCode}`);
                                // Préparer le sélecteur pour ignorer l'événement onChange
                                if (geocacheSelect) {
                                    geocacheSelect.dataset.skipAssociation = "true";
                                    geocacheSelect.value = firstGeocache.id;
                                }
                            }
                        }
                    }
                }
            } else {
                console.log("Aucune suggestion ou association automatique (skipAutoAssociation=true)");
            }
        } else {
            console.error("Éléments d'interface manquants pour l'association de géocache");
        }
    }

    // Initialiser le sélecteur de géocache
    function initGeocacheSelector(element, selectElement, skipAutoAssociation = false) {
        console.log("Chargement des géocaches ouvertes" + (skipAutoAssociation ? " (sans association auto)" : ""));
        
        // S'assurer que le flag est correctement défini
        if (skipAutoAssociation) {
            selectElement.dataset.skipAssociation = "true";
        }
        
        // Vider le sélecteur
        const defaultOption = document.createElement('option');
        defaultOption.value = "";
        defaultOption.textContent = "Sélectionner une géocache...";
        selectElement.innerHTML = '';
        selectElement.appendChild(defaultOption);
        
        // Récupérer les géocaches ouvertes via le gestionnaire d'état de layout
        try {
            if (window.layoutStateManager) {
                const openGeocaches = window.layoutStateManager.getComponentsByType('geocache-details');
                console.log(`${openGeocaches.length} géocaches ouvertes trouvées`);
                
                if (openGeocaches.length === 0) {
                    console.log("Aucune géocache ouverte trouvée");
                    // Ne plus charger les géocaches récentes du sessionStorage
                    return;
                }

                console.log("Premier élément de géocache:", openGeocaches[0]);
                console.log("Propriétés metadata:", openGeocaches[0].metadata);
                
                // Ajouter chaque géocache au sélecteur
                openGeocaches.forEach((gc, index) => {
                    if (!gc.metadata) {
                        console.warn(`Géocache ${index} sans métadonnées:`, gc);
                        return;
                    }
                    
                    // Extraire le code GC
                    let gcCode = null;
                    if (gc.metadata.gcCode) {
                        gcCode = gc.metadata.gcCode;
                        console.log(`Utilisation de gc.metadata.gcCode: ${gcCode}`);
                    } else if (gc.metadata.code) {
                        gcCode = gc.metadata.code;
                        console.log(`Utilisation de gc.metadata.code: ${gcCode}`);
                    }
                    
                    if (!gcCode) {
                        console.warn(`Géocache ${index} sans code GC:`, gc);
                        return;
                    }

                    // Créer l'option
                    const option = document.createElement('option');
                    option.value = gc.id;
                    option.textContent = `${gc.metadata.name || 'Sans nom'} (${gcCode})`;
                    
                    // Ajouter les données dans les attributs data-*
                    option.dataset.name = gc.metadata.name || 'Sans nom';
                    option.dataset.gcCode = gcCode;
                    option.dataset.databaseId = gc.metadata.databaseId || '';
                    
                    console.log(`Option ajoutée: ${option.textContent} avec code=${option.dataset.gcCode}`);
                    
                    selectElement.appendChild(option);
                    
                    // Stocker également dans sessionStorage pour référence future
                    try {
                        const recentGeocaches = JSON.parse(sessionStorage.getItem('recent_geocaches') || '[]');
                        const existingIndex = recentGeocaches.findIndex(item => item.code === gcCode);
                        
                        const geocacheInfo = {
                            id: gc.id,
                            code: gcCode,
                            name: gc.metadata.name || 'Sans nom',
                            databaseId: gc.metadata.databaseId || null
                        };
                        
                        if (existingIndex >= 0) {
                            // Mettre à jour l'entrée existante
                            recentGeocaches[existingIndex] = geocacheInfo;
                        } else {
                            // Ajouter une nouvelle entrée
                            recentGeocaches.push(geocacheInfo);
                        }
                        
                        // Limiter à 10 entrées récentes
                        while (recentGeocaches.length > 10) {
                            recentGeocaches.shift();
                        }
                        
                        sessionStorage.setItem('recent_geocaches', JSON.stringify(recentGeocaches));
                    } catch (error) {
                        console.error("Erreur lors du stockage des géocaches récentes:", error);
                    }
                });
                
                console.log(`${selectElement.options.length - 1} géocaches ajoutées au sélecteur`);
            } else {
                console.warn("layoutStateManager non disponible");
            }
        } catch (error) {
            console.error("Erreur lors du chargement des géocaches ouvertes:", error);
        }
    }

    // Charger l'association depuis sessionStorage
    function loadGeocacheAssociation(element, skipFallback = false) {
        // Vérifier si l'élément a le flag pour désactiver complètement l'association automatique
        const disableAutoAssociation = element.dataset.disableAutoAssociation === "true";
        if (disableAutoAssociation) {
            console.log("Association automatique complètement désactivée");
            skipFallback = true;
        }
        
        const pluginName = element.querySelector('h1.text-2xl.font-bold.text-blue-400')?.textContent.trim();
        if (!pluginName) {
            console.warn("Impossible de déterminer le nom du plugin pour charger l'association");
            return null;
        }
        
        const storageKey = `plugin_${pluginName}_geocache`;
        console.log(`Tentative de chargement de l'association pour ${pluginName} depuis la clé ${storageKey}`);
        
        const saved = sessionStorage.getItem(storageKey);
        if (saved) {
            try {
                const geocache = JSON.parse(saved);
                console.log(`Association chargée pour ${pluginName}:`, geocache);
                
                // Vérifier que le code GC est présent
                if (!geocache.code) {
                    console.error("Association invalide: code GC manquant");
                    sessionStorage.removeItem(storageKey);
                    return null;
                }
                
                return geocache;
            } catch (e) {
                console.error("Erreur lors du chargement de l'association:", e);
                sessionStorage.removeItem(storageKey);
                }
            } else {
            console.log(`Aucune association enregistrée pour ${pluginName}`);
            
            // Désactiver le fallback si demandé
            if (skipFallback) {
                console.log("Fallback désactivé: aucune géocache ne sera suggérée automatiquement");
                return null;
            }
            
            // Essayer de récupérer le code GC des autres façons si l'association n'existe pas
            if (window.layoutStateManager) {
                const openGeocaches = window.layoutStateManager.getComponentsByType('geocache-details');
                if (openGeocaches.length > 0) {
                    // Prendre la première géocache ouverte comme fallback
                    const firstGeocache = openGeocaches[0];
                    if (firstGeocache && firstGeocache.metadata) {
                        const gcCode = firstGeocache.metadata.gcCode || firstGeocache.metadata.code;
                        if (gcCode) {
                            console.log(`Utilisation de la première géocache ouverte ${gcCode} comme fallback`);
                            return {
                                id: firstGeocache.id,
                                name: firstGeocache.metadata.name || "Sans nom",
                                code: gcCode,
                                databaseId: firstGeocache.metadata.databaseId || null
                            };
                        }
                    }
                }
                
                // Rechercher dans les données de l'URL
                const urlParams = new URLSearchParams(window.location.search);
                const gcId = urlParams.get('geocacheId');
                if (gcId && gcId !== 'default') {
                    console.log(`Tentative de récupération du code GC à partir de l'ID: ${gcId}`);
                    
                    // Chercher parmi les géocaches ouvertes
                    const matchingGeocache = openGeocaches.find(gc => 
                        gc.metadata && gc.metadata.databaseId === gcId
                    );
                    
                    if (matchingGeocache && matchingGeocache.metadata) {
                        const gcCode = matchingGeocache.metadata.gcCode || matchingGeocache.metadata.code;
                        if (gcCode) {
                            console.log(`Géocache trouvée via l'ID: ${gcCode}`);
                            return {
                                id: matchingGeocache.id,
                                name: matchingGeocache.metadata.name || "Sans nom",
                                code: gcCode,
                                databaseId: matchingGeocache.metadata.databaseId || null
                            };
                        }
                    }
                }
            }
        }
        return null;
    }

    // Méthode pour associer une géocache (fonction commune)
    function associateGeocache(element, geocache) {
        console.log("Association de la géocache:", geocache);
        
        // Vérifier que le code GC est présent
        if (!geocache || !geocache.code) {
            console.error("Tentative d'association avec une géocache sans code GC:", geocache);
            showErrorMessage(element, "La géocache n'a pas de code GC valide");
            return;
        }
        
        // S'assurer que le code GC est au format standard (commence par GC)
        if (!geocache.code.startsWith('GC')) {
            geocache.code = `GC${geocache.code}`;
            console.log(`Code GC normalisé: ${geocache.code}`);
        }
        
        // Mettre à jour l'affichage
        const nameElement = element.querySelector('[data-plugin-interface-target="associatedGeocacheName"]');
        const codeElement = element.querySelector('[data-plugin-interface-target="associatedGeocacheCode"]');
        const infoElement = element.querySelector('[data-plugin-interface-target="associatedGeocacheInfo"]');
        const selectElement = element.querySelector('[data-plugin-interface-target="geocacheSelect"]');
        const coordsValueElement = element.querySelector('[data-plugin-interface-target="originalCoordinatesValue"]');
        
        if (nameElement && codeElement && infoElement) {
            nameElement.textContent = geocache.name || "Sans nom";
            codeElement.textContent = geocache.code;
            infoElement.classList.remove('hidden');
            
            // Mettre à jour le sélecteur si la géocache est ouverte
            if (geocache.id && selectElement) {
                selectElement.value = geocache.id;
            }
        } else {
            console.error("Éléments d'interface manquants pour afficher l'association");
        }
        
        // Enregistrer l'association dans le sessionStorage
        saveGeocacheAssociation(element, geocache);
        
        // Charger et afficher les coordonnées d'origine
        loadAndDisplayOriginalCoordinates(element, geocache);
        
        // Attachement global pour débogage
        window.lastAssociatedGeocache = geocache;
        console.log("Géocache associée et stockée dans window.lastAssociatedGeocache:", geocache);
    }
    
    // Sauvegarder l'association dans sessionStorage
    function saveGeocacheAssociation(element, geocache) {
        if (!geocache || !geocache.code) {
            console.warn("Tentative de sauvegarde d'une association sans code GC");
            return;
        }
        
        const pluginName = element.querySelector('h1.text-2xl.font-bold.text-blue-400')?.textContent.trim();
        if (!pluginName) {
            console.warn("Impossible de déterminer le nom du plugin pour sauvegarder l'association");
            return;
        }
        
        const storageKey = `plugin_${pluginName}_geocache`;
        
        // Sauvegarder dans le sessionStorage
        sessionStorage.setItem(storageKey, JSON.stringify({
            id: geocache.id || null,
            name: geocache.name || "Sans nom",
            code: geocache.code,
            databaseId: geocache.databaseId || null
        }));
        
        // Stocker également dans la variable globale pour référence
        window.lastAssociatedGeocache = {
            id: geocache.id || null,
            name: geocache.name || "Sans nom",
            code: geocache.code,
            databaseId: geocache.databaseId || null
        };
        
        console.log(`Association sauvegardée pour ${pluginName} avec le code ${geocache.code}`);
    }
    
    // Charger et afficher les coordonnées d'origine
    function loadAndDisplayOriginalCoordinates(element, geocache) {
        if (!geocache || !geocache.code) {
            console.error("Impossible de charger les coordonnées: code GC manquant");
            return;
        }
        
        const coordsValueElement = element.querySelector('[data-plugin-interface-target="originalCoordinatesValue"]');
        if (!coordsValueElement) {
            console.warn("Élément d'affichage des coordonnées introuvable");
            return;
        }
        
        // Afficher l'état de chargement
        coordsValueElement.textContent = "Chargement...";
        
        console.log(`Chargement des coordonnées pour ${geocache.code}`);
        
        // Appel API
        fetch(`/api/geocaches/by-code/${geocache.code}`)
            .then(response => {
                if (!response.ok) {
                    throw new Error(`Impossible de récupérer les coordonnées pour ${geocache.code}`);
                }
                return response.json();
            })
            .then(data => {
                console.log("Données de coordonnées reçues:", data);
                
                // Afficher les coordonnées
                const coordsStr = data.gc_lat && data.gc_lon ? 
                    `${data.gc_lat} ${data.gc_lon}` : 'Non disponibles';
                coordsValueElement.textContent = coordsStr;
                
                console.log(`Coordonnées affichées: ${coordsStr}`);
            })
            .catch(error => {
                console.error("Erreur lors du chargement des coordonnées:", error);
                coordsValueElement.textContent = "Erreur lors du chargement";
            });
    }
</script>

<!-- Inclure le contrôleur des coordonnées -->
<script>
// Configuration directe du contrôleur des coordonnées sans tenter de charger un fichier externe
(function setupCoordinatesController() {
    console.log("Configuration du contrôleur des coordonnées directement intégré");
    
    // Configuration des gestionnaires d'événements pour les coordonnées
    document.addEventListener('coordinatesDetected', function(event) {
        const coordinates = event.detail;
        if (!coordinates || !coordinates.exist) return;
        
        console.log('Traitement des coordonnées détectées:', coordinates);
    });
    
    // Le reste est géré directement par les fonctions setupCoordinateButtons
    // qui sont appelées après avoir ajouté les résultats au DOM
})();
</script>
